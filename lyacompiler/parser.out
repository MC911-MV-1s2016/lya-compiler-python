Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    CCONST
    CIRCUMF
    PRINT
    FOR
    PRED
    NUM
    TIMESASSIGN
    THEN
    END
    EXIT
    ARROW
    DBLQUO
    PROC
    LENGTH
    BY
    CONCATASSIGN
    LCURL
    NULL
    READ
    SINGQUO
    WHILE
    LOC
    SCONST
    FI
    DO
    DIVIDEASSIGN
    LOWER
    SUCC
    CONCAT
    PLUSASSIGN
    TO
    ELSIF
    UPPER
    IF
    RETURNS
    DBLSLASH
    TRUE
    PERCASSIGN
    ELSE
    MINUSASSIGN
    DOWN
    FALSE
    RCURL
    RETURN
    RESULT
    OD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> statement
Rule 4     statement -> declaration_statement
Rule 5     statement -> synonym_statement
Rule 6     statement -> newmode_statement
Rule 7     declaration_statement -> DCL declaration_list SEMICOL
Rule 8     synonym_statement -> SYN synonym_list SEMICOL
Rule 9     newmode_statement -> TYPE newmode_list SEMICOL
Rule 10    declaration_list -> declaration_list COMMA declaration
Rule 11    declaration_list -> declaration
Rule 12    declaration -> identifier_list mode initialization
Rule 13    declaration -> identifier_list mode
Rule 14    initialization -> ASSIGN expression
Rule 15    synonym_list -> synonym_list COMMA synonym_definition
Rule 16    synonym_list -> synonym_definition
Rule 17    synonym_definition -> identifier_list mode ASSIGN constant_expression
Rule 18    synonym_definition -> identifier_list ASSIGN constant_expression
Rule 19    constant_expression -> expression
Rule 20    newmode_list -> newmode_list COMMA mode_definition
Rule 21    newmode_list -> mode_definition
Rule 22    mode_definition -> identifier_list ASSIGN mode
Rule 23    mode -> mode_name
Rule 24    mode -> discrete_mode
Rule 25    mode -> reference_mode
Rule 26    mode -> composite_mode
Rule 27    discrete_mode -> integer_mode
Rule 28    discrete_mode -> boolean_mode
Rule 29    discrete_mode -> character_mode
Rule 30    discrete_mode -> discrete_range_mode
Rule 31    integer_mode -> INT
Rule 32    boolean_mode -> BOOL
Rule 33    character_mode -> CHAR
Rule 34    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 35    discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN
Rule 36    mode_name -> identifier
Rule 37    discrete_mode_name -> identifier
Rule 38    literal_range -> lower_bound COLON upper_bound
Rule 39    lower_bound -> expression
Rule 40    upper_bound -> expression
Rule 41    reference_mode -> REF mode
Rule 42    composite_mode -> string_mode
Rule 43    composite_mode -> array_mode
Rule 44    string_mode -> CHARS LBRACK string_length RBRACK
Rule 45    string_length -> integer_literal
Rule 46    array_mode -> ARRAY LBRACK index_mode_list RBRACK element_mode
Rule 47    index_mode_list -> index_mode_list COMMA index_mode
Rule 48    index_mode_list -> index_mode
Rule 49    index_mode -> discrete_mode
Rule 50    index_mode -> literal_range
Rule 51    element_mode -> mode
Rule 52    identifier_list -> identifier
Rule 53    identifier_list -> identifier_list COMMA identifier
Rule 54    identifier -> ID
Rule 55    integer_literal -> ICONST
Rule 56    expression -> operand0
Rule 57    operand0 -> operand1
Rule 58    operand0 -> operand0 operator1 operand1
Rule 59    operator1 -> relational_operator
Rule 60    operator1 -> membership_operator
Rule 61    relational_operator -> AND
Rule 62    relational_operator -> OR
Rule 63    relational_operator -> EQUALS
Rule 64    relational_operator -> DIF
Rule 65    relational_operator -> GTR
Rule 66    relational_operator -> GEQ
Rule 67    relational_operator -> LSS
Rule 68    relational_operator -> LEQ
Rule 69    membership_operator -> IN
Rule 70    operand1 -> operand2
Rule 71    operand1 -> operand1 operator2 operand2
Rule 72    operator2 -> arithmetic_additive_operator
Rule 73    arithmetic_additive_operator -> PLUS
Rule 74    arithmetic_additive_operator -> MINUS
Rule 75    operand2 -> operand3
Rule 76    operand2 -> operand2 arithmetic_multiplicative_operator operand3
Rule 77    arithmetic_multiplicative_operator -> TIMES
Rule 78    arithmetic_multiplicative_operator -> DIVIDE
Rule 79    arithmetic_multiplicative_operator -> PERC
Rule 80    operand3 -> monadic_operator operand4
Rule 81    operand3 -> operand4
Rule 82    monadic_operator -> MINUS
Rule 83    monadic_operator -> NOT
Rule 84    operand4 -> ICONST

Terminals, with rules where they appear

AND                  : 61
ARRAY                : 46
ARROW                : 
ASSIGN               : 14 17 18 22
BOOL                 : 32
BY                   : 
CCONST               : 
CHAR                 : 33
CHARS                : 44
CIRCUMF              : 
COLON                : 38
COMMA                : 10 15 20 47 53
CONCAT               : 
CONCATASSIGN         : 
DBLQUO               : 
DBLSLASH             : 
DCL                  : 7
DIF                  : 64
DIVIDE               : 78
DIVIDEASSIGN         : 
DO                   : 
DOWN                 : 
ELSE                 : 
ELSIF                : 
END                  : 
EQUALS               : 63
EXIT                 : 
FALSE                : 
FI                   : 
FOR                  : 
GEQ                  : 66
GTR                  : 65
ICONST               : 55 84
ID                   : 54
IF                   : 
IN                   : 69
INT                  : 31
LBRACK               : 44 46
LCURL                : 
LENGTH               : 
LEQ                  : 68
LOC                  : 
LOWER                : 
LPAREN               : 34 35
LSS                  : 67
MINUS                : 74 82
MINUSASSIGN          : 
NOT                  : 83
NULL                 : 
NUM                  : 
OD                   : 
OR                   : 62
PERC                 : 79
PERCASSIGN           : 
PLUS                 : 73
PLUSASSIGN           : 
PRED                 : 
PRINT                : 
PROC                 : 
RBRACK               : 44 46
RCURL                : 
READ                 : 
REF                  : 41
RESULT               : 
RETURN               : 
RETURNS              : 
RPAREN               : 34 35
SCONST               : 
SEMICOL              : 7 8 9
SINGQUO              : 
SUCC                 : 
SYN                  : 8
THEN                 : 
TIMES                : 77
TIMESASSIGN          : 
TO                   : 
TRUE                 : 
TYPE                 : 9
UPPER                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_additive_operator : 72
arithmetic_multiplicative_operator : 76
array_mode           : 43
boolean_mode         : 28
character_mode       : 29
composite_mode       : 26
constant_expression  : 17 18
declaration          : 10 11
declaration_list     : 7 10
declaration_statement : 4
discrete_mode        : 24 35 49
discrete_mode_name   : 34
discrete_range_mode  : 30
element_mode         : 46
expression           : 14 19 39 40
identifier           : 36 37 52 53
identifier_list      : 12 13 17 18 22 53
index_mode           : 47 48
index_mode_list      : 46 47
initialization       : 12
integer_literal      : 45
integer_mode         : 27
literal_range        : 34 35 50
lower_bound          : 38
membership_operator  : 60
mode                 : 12 13 17 22 41 51
mode_definition      : 20 21
mode_name            : 23
monadic_operator     : 80
newmode_list         : 9 20
newmode_statement    : 6
operand0             : 56 58
operand1             : 57 58 71
operand2             : 70 71 76
operand3             : 75 76
operand4             : 80 81
operator1            : 58
operator2            : 71
program              : 0
reference_mode       : 25
relational_operator  : 59
statement            : 2 3
statement_list       : 1 2
string_length        : 44
string_mode          : 42
synonym_definition   : 15 16
synonym_list         : 8 15
synonym_statement    : 5
upper_bound          : 38

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) declaration_statement -> . DCL declaration_list SEMICOL
    (8) synonym_statement -> . SYN synonym_list SEMICOL
    (9) newmode_statement -> . TYPE newmode_list SEMICOL

    DCL             shift and go to state 5
    SYN             shift and go to state 1
    TYPE            shift and go to state 3

    newmode_statement              shift and go to state 6
    declaration_statement          shift and go to state 2
    statement_list                 shift and go to state 7
    program                        shift and go to state 8
    statement                      shift and go to state 4
    synonym_statement              shift and go to state 9

state 1

    (8) synonym_statement -> SYN . synonym_list SEMICOL
    (15) synonym_list -> . synonym_list COMMA synonym_definition
    (16) synonym_list -> . synonym_definition
    (17) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (18) synonym_definition -> . identifier_list ASSIGN constant_expression
    (52) identifier_list -> . identifier
    (53) identifier_list -> . identifier_list COMMA identifier
    (54) identifier -> . ID

    ID              shift and go to state 10

    synonym_definition             shift and go to state 11
    synonym_list                   shift and go to state 14
    identifier                     shift and go to state 13
    identifier_list                shift and go to state 12

state 2

    (4) statement -> declaration_statement .

    DCL             reduce using rule 4 (statement -> declaration_statement .)
    SYN             reduce using rule 4 (statement -> declaration_statement .)
    TYPE            reduce using rule 4 (statement -> declaration_statement .)
    $end            reduce using rule 4 (statement -> declaration_statement .)


state 3

    (9) newmode_statement -> TYPE . newmode_list SEMICOL
    (20) newmode_list -> . newmode_list COMMA mode_definition
    (21) newmode_list -> . mode_definition
    (22) mode_definition -> . identifier_list ASSIGN mode
    (52) identifier_list -> . identifier
    (53) identifier_list -> . identifier_list COMMA identifier
    (54) identifier -> . ID

    ID              shift and go to state 10

    newmode_list                   shift and go to state 15
    mode_definition                shift and go to state 17
    identifier                     shift and go to state 13
    identifier_list                shift and go to state 16

state 4

    (3) statement_list -> statement .

    DCL             reduce using rule 3 (statement_list -> statement .)
    SYN             reduce using rule 3 (statement_list -> statement .)
    TYPE            reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)


state 5

    (7) declaration_statement -> DCL . declaration_list SEMICOL
    (10) declaration_list -> . declaration_list COMMA declaration
    (11) declaration_list -> . declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (52) identifier_list -> . identifier
    (53) identifier_list -> . identifier_list COMMA identifier
    (54) identifier -> . ID

    ID              shift and go to state 10

    declaration_list               shift and go to state 18
    identifier                     shift and go to state 13
    declaration                    shift and go to state 19
    identifier_list                shift and go to state 20

state 6

    (6) statement -> newmode_statement .

    DCL             reduce using rule 6 (statement -> newmode_statement .)
    SYN             reduce using rule 6 (statement -> newmode_statement .)
    TYPE            reduce using rule 6 (statement -> newmode_statement .)
    $end            reduce using rule 6 (statement -> newmode_statement .)


state 7

    (1) program -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) declaration_statement -> . DCL declaration_list SEMICOL
    (8) synonym_statement -> . SYN synonym_list SEMICOL
    (9) newmode_statement -> . TYPE newmode_list SEMICOL

    $end            reduce using rule 1 (program -> statement_list .)
    DCL             shift and go to state 5
    SYN             shift and go to state 1
    TYPE            shift and go to state 3

    declaration_statement          shift and go to state 2
    synonym_statement              shift and go to state 9
    statement                      shift and go to state 21
    newmode_statement              shift and go to state 6

state 8

    (0) S' -> program .



state 9

    (5) statement -> synonym_statement .

    DCL             reduce using rule 5 (statement -> synonym_statement .)
    SYN             reduce using rule 5 (statement -> synonym_statement .)
    TYPE            reduce using rule 5 (statement -> synonym_statement .)
    $end            reduce using rule 5 (statement -> synonym_statement .)


state 10

    (54) identifier -> ID .

    ASSIGN          reduce using rule 54 (identifier -> ID .)
    SEMICOL         reduce using rule 54 (identifier -> ID .)
    COMMA           reduce using rule 54 (identifier -> ID .)
    LPAREN          reduce using rule 54 (identifier -> ID .)
    REF             reduce using rule 54 (identifier -> ID .)
    ID              reduce using rule 54 (identifier -> ID .)
    INT             reduce using rule 54 (identifier -> ID .)
    BOOL            reduce using rule 54 (identifier -> ID .)
    CHAR            reduce using rule 54 (identifier -> ID .)
    CHARS           reduce using rule 54 (identifier -> ID .)
    ARRAY           reduce using rule 54 (identifier -> ID .)


state 11

    (16) synonym_list -> synonym_definition .

    SEMICOL         reduce using rule 16 (synonym_list -> synonym_definition .)
    COMMA           reduce using rule 16 (synonym_list -> synonym_definition .)


state 12

    (17) synonym_definition -> identifier_list . mode ASSIGN constant_expression
    (18) synonym_definition -> identifier_list . ASSIGN constant_expression
    (53) identifier_list -> identifier_list . COMMA identifier
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (26) mode -> . composite_mode
    (36) mode_name -> . identifier
    (27) discrete_mode -> . integer_mode
    (28) discrete_mode -> . boolean_mode
    (29) discrete_mode -> . character_mode
    (30) discrete_mode -> . discrete_range_mode
    (41) reference_mode -> . REF mode
    (42) composite_mode -> . string_mode
    (43) composite_mode -> . array_mode
    (54) identifier -> . ID
    (31) integer_mode -> . INT
    (32) boolean_mode -> . BOOL
    (33) character_mode -> . CHAR
    (34) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (35) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (44) string_mode -> . CHARS LBRACK string_length RBRACK
    (46) array_mode -> . ARRAY LBRACK index_mode_list RBRACK element_mode
    (37) discrete_mode_name -> . identifier

    ASSIGN          shift and go to state 22
    COMMA           shift and go to state 27
    REF             shift and go to state 34
    ID              shift and go to state 10
    INT             shift and go to state 36
    BOOL            shift and go to state 23
    CHAR            shift and go to state 26
    CHARS           shift and go to state 29
    ARRAY           shift and go to state 32

    string_mode                    shift and go to state 33
    discrete_mode                  shift and go to state 24
    discrete_range_mode            shift and go to state 35
    array_mode                     shift and go to state 25
    character_mode                 shift and go to state 37
    discrete_mode_name             shift and go to state 38
    composite_mode                 shift and go to state 28
    mode                           shift and go to state 39
    integer_mode                   shift and go to state 41
    reference_mode                 shift and go to state 40
    boolean_mode                   shift and go to state 30
    mode_name                      shift and go to state 42
    identifier                     shift and go to state 31

state 13

    (52) identifier_list -> identifier .

    COMMA           reduce using rule 52 (identifier_list -> identifier .)
    REF             reduce using rule 52 (identifier_list -> identifier .)
    ID              reduce using rule 52 (identifier_list -> identifier .)
    INT             reduce using rule 52 (identifier_list -> identifier .)
    BOOL            reduce using rule 52 (identifier_list -> identifier .)
    CHAR            reduce using rule 52 (identifier_list -> identifier .)
    CHARS           reduce using rule 52 (identifier_list -> identifier .)
    ARRAY           reduce using rule 52 (identifier_list -> identifier .)
    ASSIGN          reduce using rule 52 (identifier_list -> identifier .)


state 14

    (8) synonym_statement -> SYN synonym_list . SEMICOL
    (15) synonym_list -> synonym_list . COMMA synonym_definition

    SEMICOL         shift and go to state 44
    COMMA           shift and go to state 43


state 15

    (9) newmode_statement -> TYPE newmode_list . SEMICOL
    (20) newmode_list -> newmode_list . COMMA mode_definition

    SEMICOL         shift and go to state 45
    COMMA           shift and go to state 46


state 16

    (22) mode_definition -> identifier_list . ASSIGN mode
    (53) identifier_list -> identifier_list . COMMA identifier

    ASSIGN          shift and go to state 47
    COMMA           shift and go to state 27


state 17

    (21) newmode_list -> mode_definition .

    SEMICOL         reduce using rule 21 (newmode_list -> mode_definition .)
    COMMA           reduce using rule 21 (newmode_list -> mode_definition .)


state 18

    (7) declaration_statement -> DCL declaration_list . SEMICOL
    (10) declaration_list -> declaration_list . COMMA declaration

    SEMICOL         shift and go to state 49
    COMMA           shift and go to state 48


state 19

    (11) declaration_list -> declaration .

    SEMICOL         reduce using rule 11 (declaration_list -> declaration .)
    COMMA           reduce using rule 11 (declaration_list -> declaration .)


state 20

    (12) declaration -> identifier_list . mode initialization
    (13) declaration -> identifier_list . mode
    (53) identifier_list -> identifier_list . COMMA identifier
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (26) mode -> . composite_mode
    (36) mode_name -> . identifier
    (27) discrete_mode -> . integer_mode
    (28) discrete_mode -> . boolean_mode
    (29) discrete_mode -> . character_mode
    (30) discrete_mode -> . discrete_range_mode
    (41) reference_mode -> . REF mode
    (42) composite_mode -> . string_mode
    (43) composite_mode -> . array_mode
    (54) identifier -> . ID
    (31) integer_mode -> . INT
    (32) boolean_mode -> . BOOL
    (33) character_mode -> . CHAR
    (34) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (35) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (44) string_mode -> . CHARS LBRACK string_length RBRACK
    (46) array_mode -> . ARRAY LBRACK index_mode_list RBRACK element_mode
    (37) discrete_mode_name -> . identifier

    COMMA           shift and go to state 27
    REF             shift and go to state 34
    ID              shift and go to state 10
    INT             shift and go to state 36
    BOOL            shift and go to state 23
    CHAR            shift and go to state 26
    CHARS           shift and go to state 29
    ARRAY           shift and go to state 32

    string_mode                    shift and go to state 33
    discrete_mode                  shift and go to state 24
    discrete_range_mode            shift and go to state 35
    array_mode                     shift and go to state 25
    mode_name                      shift and go to state 42
    character_mode                 shift and go to state 37
    discrete_mode_name             shift and go to state 38
    mode                           shift and go to state 50
    integer_mode                   shift and go to state 41
    reference_mode                 shift and go to state 40
    composite_mode                 shift and go to state 28
    boolean_mode                   shift and go to state 30
    identifier                     shift and go to state 31

state 21

    (2) statement_list -> statement_list statement .

    DCL             reduce using rule 2 (statement_list -> statement_list statement .)
    SYN             reduce using rule 2 (statement_list -> statement_list statement .)
    TYPE            reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)


state 22

    (18) synonym_definition -> identifier_list ASSIGN . constant_expression
    (19) constant_expression -> . expression
    (56) expression -> . operand0
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand2                       shift and go to state 53
    operand4                       shift and go to state 52
    monadic_operator               shift and go to state 56
    operand1                       shift and go to state 60
    operand3                       shift and go to state 57
    constant_expression            shift and go to state 58
    operand0                       shift and go to state 59
    expression                     shift and go to state 55

state 23

    (32) boolean_mode -> BOOL .

    LPAREN          reduce using rule 32 (boolean_mode -> BOOL .)
    ASSIGN          reduce using rule 32 (boolean_mode -> BOOL .)
    SEMICOL         reduce using rule 32 (boolean_mode -> BOOL .)
    COMMA           reduce using rule 32 (boolean_mode -> BOOL .)
    RBRACK          reduce using rule 32 (boolean_mode -> BOOL .)


state 24

    (24) mode -> discrete_mode .
    (35) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    ASSIGN          reduce using rule 24 (mode -> discrete_mode .)
    SEMICOL         reduce using rule 24 (mode -> discrete_mode .)
    COMMA           reduce using rule 24 (mode -> discrete_mode .)
    LPAREN          shift and go to state 62


state 25

    (43) composite_mode -> array_mode .

    ASSIGN          reduce using rule 43 (composite_mode -> array_mode .)
    SEMICOL         reduce using rule 43 (composite_mode -> array_mode .)
    COMMA           reduce using rule 43 (composite_mode -> array_mode .)


state 26

    (33) character_mode -> CHAR .

    LPAREN          reduce using rule 33 (character_mode -> CHAR .)
    ASSIGN          reduce using rule 33 (character_mode -> CHAR .)
    SEMICOL         reduce using rule 33 (character_mode -> CHAR .)
    COMMA           reduce using rule 33 (character_mode -> CHAR .)
    RBRACK          reduce using rule 33 (character_mode -> CHAR .)


state 27

    (53) identifier_list -> identifier_list COMMA . identifier
    (54) identifier -> . ID

    ID              shift and go to state 10

    identifier                     shift and go to state 63

state 28

    (26) mode -> composite_mode .

    ASSIGN          reduce using rule 26 (mode -> composite_mode .)
    SEMICOL         reduce using rule 26 (mode -> composite_mode .)
    COMMA           reduce using rule 26 (mode -> composite_mode .)


state 29

    (44) string_mode -> CHARS . LBRACK string_length RBRACK

    LBRACK          shift and go to state 64


state 30

    (28) discrete_mode -> boolean_mode .

    LPAREN          reduce using rule 28 (discrete_mode -> boolean_mode .)
    ASSIGN          reduce using rule 28 (discrete_mode -> boolean_mode .)
    SEMICOL         reduce using rule 28 (discrete_mode -> boolean_mode .)
    COMMA           reduce using rule 28 (discrete_mode -> boolean_mode .)
    RBRACK          reduce using rule 28 (discrete_mode -> boolean_mode .)


state 31

    (36) mode_name -> identifier .
    (37) discrete_mode_name -> identifier .

    ASSIGN          reduce using rule 36 (mode_name -> identifier .)
    SEMICOL         reduce using rule 36 (mode_name -> identifier .)
    COMMA           reduce using rule 36 (mode_name -> identifier .)
    LPAREN          reduce using rule 37 (discrete_mode_name -> identifier .)


state 32

    (46) array_mode -> ARRAY . LBRACK index_mode_list RBRACK element_mode

    LBRACK          shift and go to state 65


state 33

    (42) composite_mode -> string_mode .

    ASSIGN          reduce using rule 42 (composite_mode -> string_mode .)
    SEMICOL         reduce using rule 42 (composite_mode -> string_mode .)
    COMMA           reduce using rule 42 (composite_mode -> string_mode .)


state 34

    (41) reference_mode -> REF . mode
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (26) mode -> . composite_mode
    (36) mode_name -> . identifier
    (27) discrete_mode -> . integer_mode
    (28) discrete_mode -> . boolean_mode
    (29) discrete_mode -> . character_mode
    (30) discrete_mode -> . discrete_range_mode
    (41) reference_mode -> . REF mode
    (42) composite_mode -> . string_mode
    (43) composite_mode -> . array_mode
    (54) identifier -> . ID
    (31) integer_mode -> . INT
    (32) boolean_mode -> . BOOL
    (33) character_mode -> . CHAR
    (34) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (35) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (44) string_mode -> . CHARS LBRACK string_length RBRACK
    (46) array_mode -> . ARRAY LBRACK index_mode_list RBRACK element_mode
    (37) discrete_mode_name -> . identifier

    REF             shift and go to state 34
    ID              shift and go to state 10
    INT             shift and go to state 36
    BOOL            shift and go to state 23
    CHAR            shift and go to state 26
    CHARS           shift and go to state 29
    ARRAY           shift and go to state 32

    string_mode                    shift and go to state 33
    discrete_mode                  shift and go to state 24
    discrete_range_mode            shift and go to state 35
    array_mode                     shift and go to state 25
    character_mode                 shift and go to state 37
    discrete_mode_name             shift and go to state 38
    mode                           shift and go to state 66
    integer_mode                   shift and go to state 41
    reference_mode                 shift and go to state 40
    composite_mode                 shift and go to state 28
    boolean_mode                   shift and go to state 30
    identifier                     shift and go to state 31
    mode_name                      shift and go to state 42

state 35

    (30) discrete_mode -> discrete_range_mode .

    LPAREN          reduce using rule 30 (discrete_mode -> discrete_range_mode .)
    ASSIGN          reduce using rule 30 (discrete_mode -> discrete_range_mode .)
    SEMICOL         reduce using rule 30 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 30 (discrete_mode -> discrete_range_mode .)
    RBRACK          reduce using rule 30 (discrete_mode -> discrete_range_mode .)


state 36

    (31) integer_mode -> INT .

    LPAREN          reduce using rule 31 (integer_mode -> INT .)
    RBRACK          reduce using rule 31 (integer_mode -> INT .)
    COMMA           reduce using rule 31 (integer_mode -> INT .)
    ASSIGN          reduce using rule 31 (integer_mode -> INT .)
    SEMICOL         reduce using rule 31 (integer_mode -> INT .)


state 37

    (29) discrete_mode -> character_mode .

    LPAREN          reduce using rule 29 (discrete_mode -> character_mode .)
    ASSIGN          reduce using rule 29 (discrete_mode -> character_mode .)
    SEMICOL         reduce using rule 29 (discrete_mode -> character_mode .)
    COMMA           reduce using rule 29 (discrete_mode -> character_mode .)
    RBRACK          reduce using rule 29 (discrete_mode -> character_mode .)


state 38

    (34) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 67


state 39

    (17) synonym_definition -> identifier_list mode . ASSIGN constant_expression

    ASSIGN          shift and go to state 68


state 40

    (25) mode -> reference_mode .

    ASSIGN          reduce using rule 25 (mode -> reference_mode .)
    SEMICOL         reduce using rule 25 (mode -> reference_mode .)
    COMMA           reduce using rule 25 (mode -> reference_mode .)


state 41

    (27) discrete_mode -> integer_mode .

    LPAREN          reduce using rule 27 (discrete_mode -> integer_mode .)
    ASSIGN          reduce using rule 27 (discrete_mode -> integer_mode .)
    SEMICOL         reduce using rule 27 (discrete_mode -> integer_mode .)
    COMMA           reduce using rule 27 (discrete_mode -> integer_mode .)
    RBRACK          reduce using rule 27 (discrete_mode -> integer_mode .)


state 42

    (23) mode -> mode_name .

    ASSIGN          reduce using rule 23 (mode -> mode_name .)
    SEMICOL         reduce using rule 23 (mode -> mode_name .)
    COMMA           reduce using rule 23 (mode -> mode_name .)


state 43

    (15) synonym_list -> synonym_list COMMA . synonym_definition
    (17) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (18) synonym_definition -> . identifier_list ASSIGN constant_expression
    (52) identifier_list -> . identifier
    (53) identifier_list -> . identifier_list COMMA identifier
    (54) identifier -> . ID

    ID              shift and go to state 10

    synonym_definition             shift and go to state 69
    identifier                     shift and go to state 13
    identifier_list                shift and go to state 12

state 44

    (8) synonym_statement -> SYN synonym_list SEMICOL .

    DCL             reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)
    SYN             reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)
    TYPE            reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)
    $end            reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)


state 45

    (9) newmode_statement -> TYPE newmode_list SEMICOL .

    DCL             reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)
    SYN             reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)
    TYPE            reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)
    $end            reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)


state 46

    (20) newmode_list -> newmode_list COMMA . mode_definition
    (22) mode_definition -> . identifier_list ASSIGN mode
    (52) identifier_list -> . identifier
    (53) identifier_list -> . identifier_list COMMA identifier
    (54) identifier -> . ID

    ID              shift and go to state 10

    mode_definition                shift and go to state 70
    identifier                     shift and go to state 13
    identifier_list                shift and go to state 16

state 47

    (22) mode_definition -> identifier_list ASSIGN . mode
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (26) mode -> . composite_mode
    (36) mode_name -> . identifier
    (27) discrete_mode -> . integer_mode
    (28) discrete_mode -> . boolean_mode
    (29) discrete_mode -> . character_mode
    (30) discrete_mode -> . discrete_range_mode
    (41) reference_mode -> . REF mode
    (42) composite_mode -> . string_mode
    (43) composite_mode -> . array_mode
    (54) identifier -> . ID
    (31) integer_mode -> . INT
    (32) boolean_mode -> . BOOL
    (33) character_mode -> . CHAR
    (34) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (35) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (44) string_mode -> . CHARS LBRACK string_length RBRACK
    (46) array_mode -> . ARRAY LBRACK index_mode_list RBRACK element_mode
    (37) discrete_mode_name -> . identifier

    REF             shift and go to state 34
    ID              shift and go to state 10
    INT             shift and go to state 36
    BOOL            shift and go to state 23
    CHAR            shift and go to state 26
    CHARS           shift and go to state 29
    ARRAY           shift and go to state 32

    string_mode                    shift and go to state 33
    discrete_mode                  shift and go to state 24
    discrete_range_mode            shift and go to state 35
    array_mode                     shift and go to state 25
    character_mode                 shift and go to state 37
    discrete_mode_name             shift and go to state 38
    composite_mode                 shift and go to state 28
    mode                           shift and go to state 71
    integer_mode                   shift and go to state 41
    reference_mode                 shift and go to state 40
    boolean_mode                   shift and go to state 30
    mode_name                      shift and go to state 42
    identifier                     shift and go to state 31

state 48

    (10) declaration_list -> declaration_list COMMA . declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (52) identifier_list -> . identifier
    (53) identifier_list -> . identifier_list COMMA identifier
    (54) identifier -> . ID

    ID              shift and go to state 10

    identifier                     shift and go to state 13
    declaration                    shift and go to state 72
    identifier_list                shift and go to state 20

state 49

    (7) declaration_statement -> DCL declaration_list SEMICOL .

    DCL             reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)
    SYN             reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)
    TYPE            reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)
    $end            reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)


state 50

    (12) declaration -> identifier_list mode . initialization
    (13) declaration -> identifier_list mode .
    (14) initialization -> . ASSIGN expression

    SEMICOL         reduce using rule 13 (declaration -> identifier_list mode .)
    COMMA           reduce using rule 13 (declaration -> identifier_list mode .)
    ASSIGN          shift and go to state 73

    initialization                 shift and go to state 74

state 51

    (83) monadic_operator -> NOT .

    ICONST          reduce using rule 83 (monadic_operator -> NOT .)


state 52

    (81) operand3 -> operand4 .

    TIMES           reduce using rule 81 (operand3 -> operand4 .)
    DIVIDE          reduce using rule 81 (operand3 -> operand4 .)
    PERC            reduce using rule 81 (operand3 -> operand4 .)
    PLUS            reduce using rule 81 (operand3 -> operand4 .)
    MINUS           reduce using rule 81 (operand3 -> operand4 .)
    AND             reduce using rule 81 (operand3 -> operand4 .)
    OR              reduce using rule 81 (operand3 -> operand4 .)
    EQUALS          reduce using rule 81 (operand3 -> operand4 .)
    DIF             reduce using rule 81 (operand3 -> operand4 .)
    GTR             reduce using rule 81 (operand3 -> operand4 .)
    GEQ             reduce using rule 81 (operand3 -> operand4 .)
    LSS             reduce using rule 81 (operand3 -> operand4 .)
    LEQ             reduce using rule 81 (operand3 -> operand4 .)
    IN              reduce using rule 81 (operand3 -> operand4 .)
    SEMICOL         reduce using rule 81 (operand3 -> operand4 .)
    COMMA           reduce using rule 81 (operand3 -> operand4 .)
    COLON           reduce using rule 81 (operand3 -> operand4 .)
    RPAREN          reduce using rule 81 (operand3 -> operand4 .)
    RBRACK          reduce using rule 81 (operand3 -> operand4 .)


state 53

    (70) operand1 -> operand2 .
    (76) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (77) arithmetic_multiplicative_operator -> . TIMES
    (78) arithmetic_multiplicative_operator -> . DIVIDE
    (79) arithmetic_multiplicative_operator -> . PERC

    PLUS            reduce using rule 70 (operand1 -> operand2 .)
    MINUS           reduce using rule 70 (operand1 -> operand2 .)
    AND             reduce using rule 70 (operand1 -> operand2 .)
    OR              reduce using rule 70 (operand1 -> operand2 .)
    EQUALS          reduce using rule 70 (operand1 -> operand2 .)
    DIF             reduce using rule 70 (operand1 -> operand2 .)
    GTR             reduce using rule 70 (operand1 -> operand2 .)
    GEQ             reduce using rule 70 (operand1 -> operand2 .)
    LSS             reduce using rule 70 (operand1 -> operand2 .)
    LEQ             reduce using rule 70 (operand1 -> operand2 .)
    IN              reduce using rule 70 (operand1 -> operand2 .)
    COLON           reduce using rule 70 (operand1 -> operand2 .)
    SEMICOL         reduce using rule 70 (operand1 -> operand2 .)
    COMMA           reduce using rule 70 (operand1 -> operand2 .)
    RPAREN          reduce using rule 70 (operand1 -> operand2 .)
    RBRACK          reduce using rule 70 (operand1 -> operand2 .)
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 76
    PERC            shift and go to state 75

    arithmetic_multiplicative_operator shift and go to state 77

state 54

    (84) operand4 -> ICONST .

    TIMES           reduce using rule 84 (operand4 -> ICONST .)
    DIVIDE          reduce using rule 84 (operand4 -> ICONST .)
    PERC            reduce using rule 84 (operand4 -> ICONST .)
    PLUS            reduce using rule 84 (operand4 -> ICONST .)
    MINUS           reduce using rule 84 (operand4 -> ICONST .)
    AND             reduce using rule 84 (operand4 -> ICONST .)
    OR              reduce using rule 84 (operand4 -> ICONST .)
    EQUALS          reduce using rule 84 (operand4 -> ICONST .)
    DIF             reduce using rule 84 (operand4 -> ICONST .)
    GTR             reduce using rule 84 (operand4 -> ICONST .)
    GEQ             reduce using rule 84 (operand4 -> ICONST .)
    LSS             reduce using rule 84 (operand4 -> ICONST .)
    LEQ             reduce using rule 84 (operand4 -> ICONST .)
    IN              reduce using rule 84 (operand4 -> ICONST .)
    SEMICOL         reduce using rule 84 (operand4 -> ICONST .)
    COMMA           reduce using rule 84 (operand4 -> ICONST .)
    COLON           reduce using rule 84 (operand4 -> ICONST .)
    RPAREN          reduce using rule 84 (operand4 -> ICONST .)
    RBRACK          reduce using rule 84 (operand4 -> ICONST .)


state 55

    (19) constant_expression -> expression .

    SEMICOL         reduce using rule 19 (constant_expression -> expression .)
    COMMA           reduce using rule 19 (constant_expression -> expression .)


state 56

    (80) operand3 -> monadic_operator . operand4
    (84) operand4 -> . ICONST

    ICONST          shift and go to state 54

    operand4                       shift and go to state 79

state 57

    (75) operand2 -> operand3 .

    TIMES           reduce using rule 75 (operand2 -> operand3 .)
    DIVIDE          reduce using rule 75 (operand2 -> operand3 .)
    PERC            reduce using rule 75 (operand2 -> operand3 .)
    PLUS            reduce using rule 75 (operand2 -> operand3 .)
    MINUS           reduce using rule 75 (operand2 -> operand3 .)
    AND             reduce using rule 75 (operand2 -> operand3 .)
    OR              reduce using rule 75 (operand2 -> operand3 .)
    EQUALS          reduce using rule 75 (operand2 -> operand3 .)
    DIF             reduce using rule 75 (operand2 -> operand3 .)
    GTR             reduce using rule 75 (operand2 -> operand3 .)
    GEQ             reduce using rule 75 (operand2 -> operand3 .)
    LSS             reduce using rule 75 (operand2 -> operand3 .)
    LEQ             reduce using rule 75 (operand2 -> operand3 .)
    IN              reduce using rule 75 (operand2 -> operand3 .)
    COLON           reduce using rule 75 (operand2 -> operand3 .)
    SEMICOL         reduce using rule 75 (operand2 -> operand3 .)
    COMMA           reduce using rule 75 (operand2 -> operand3 .)
    RPAREN          reduce using rule 75 (operand2 -> operand3 .)
    RBRACK          reduce using rule 75 (operand2 -> operand3 .)


state 58

    (18) synonym_definition -> identifier_list ASSIGN constant_expression .

    SEMICOL         reduce using rule 18 (synonym_definition -> identifier_list ASSIGN constant_expression .)
    COMMA           reduce using rule 18 (synonym_definition -> identifier_list ASSIGN constant_expression .)


state 59

    (56) expression -> operand0 .
    (58) operand0 -> operand0 . operator1 operand1
    (59) operator1 -> . relational_operator
    (60) operator1 -> . membership_operator
    (61) relational_operator -> . AND
    (62) relational_operator -> . OR
    (63) relational_operator -> . EQUALS
    (64) relational_operator -> . DIF
    (65) relational_operator -> . GTR
    (66) relational_operator -> . GEQ
    (67) relational_operator -> . LSS
    (68) relational_operator -> . LEQ
    (69) membership_operator -> . IN

    COLON           reduce using rule 56 (expression -> operand0 .)
    SEMICOL         reduce using rule 56 (expression -> operand0 .)
    COMMA           reduce using rule 56 (expression -> operand0 .)
    RPAREN          reduce using rule 56 (expression -> operand0 .)
    RBRACK          reduce using rule 56 (expression -> operand0 .)
    AND             shift and go to state 88
    OR              shift and go to state 84
    EQUALS          shift and go to state 80
    DIF             shift and go to state 89
    GTR             shift and go to state 87
    GEQ             shift and go to state 81
    LSS             shift and go to state 85
    LEQ             shift and go to state 91
    IN              shift and go to state 82

    operator1                      shift and go to state 83
    relational_operator            shift and go to state 90
    membership_operator            shift and go to state 86

state 60

    (57) operand0 -> operand1 .
    (71) operand1 -> operand1 . operator2 operand2
    (72) operator2 -> . arithmetic_additive_operator
    (73) arithmetic_additive_operator -> . PLUS
    (74) arithmetic_additive_operator -> . MINUS

    AND             reduce using rule 57 (operand0 -> operand1 .)
    OR              reduce using rule 57 (operand0 -> operand1 .)
    EQUALS          reduce using rule 57 (operand0 -> operand1 .)
    DIF             reduce using rule 57 (operand0 -> operand1 .)
    GTR             reduce using rule 57 (operand0 -> operand1 .)
    GEQ             reduce using rule 57 (operand0 -> operand1 .)
    LSS             reduce using rule 57 (operand0 -> operand1 .)
    LEQ             reduce using rule 57 (operand0 -> operand1 .)
    IN              reduce using rule 57 (operand0 -> operand1 .)
    COLON           reduce using rule 57 (operand0 -> operand1 .)
    SEMICOL         reduce using rule 57 (operand0 -> operand1 .)
    COMMA           reduce using rule 57 (operand0 -> operand1 .)
    RPAREN          reduce using rule 57 (operand0 -> operand1 .)
    RBRACK          reduce using rule 57 (operand0 -> operand1 .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 94

    operator2                      shift and go to state 92
    arithmetic_additive_operator   shift and go to state 93

state 61

    (82) monadic_operator -> MINUS .

    ICONST          reduce using rule 82 (monadic_operator -> MINUS .)


state 62

    (35) discrete_range_mode -> discrete_mode LPAREN . literal_range RPAREN
    (38) literal_range -> . lower_bound COLON upper_bound
    (39) lower_bound -> . expression
    (56) expression -> . operand0
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand2                       shift and go to state 53
    literal_range                  shift and go to state 96
    expression                     shift and go to state 97
    monadic_operator               shift and go to state 56
    operand3                       shift and go to state 57
    operand4                       shift and go to state 52
    lower_bound                    shift and go to state 98
    operand0                       shift and go to state 59
    operand1                       shift and go to state 60

state 63

    (53) identifier_list -> identifier_list COMMA identifier .

    COMMA           reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    REF             reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    ID              reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    INT             reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    BOOL            reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    CHAR            reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    CHARS           reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    ARRAY           reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)
    ASSIGN          reduce using rule 53 (identifier_list -> identifier_list COMMA identifier .)


state 64

    (44) string_mode -> CHARS LBRACK . string_length RBRACK
    (45) string_length -> . integer_literal
    (55) integer_literal -> . ICONST

    ICONST          shift and go to state 100

    integer_literal                shift and go to state 99
    string_length                  shift and go to state 101

state 65

    (46) array_mode -> ARRAY LBRACK . index_mode_list RBRACK element_mode
    (47) index_mode_list -> . index_mode_list COMMA index_mode
    (48) index_mode_list -> . index_mode
    (49) index_mode -> . discrete_mode
    (50) index_mode -> . literal_range
    (27) discrete_mode -> . integer_mode
    (28) discrete_mode -> . boolean_mode
    (29) discrete_mode -> . character_mode
    (30) discrete_mode -> . discrete_range_mode
    (38) literal_range -> . lower_bound COLON upper_bound
    (31) integer_mode -> . INT
    (32) boolean_mode -> . BOOL
    (33) character_mode -> . CHAR
    (34) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (35) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (39) lower_bound -> . expression
    (37) discrete_mode_name -> . identifier
    (56) expression -> . operand0
    (54) identifier -> . ID
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    INT             shift and go to state 36
    BOOL            shift and go to state 23
    CHAR            shift and go to state 26
    ID              shift and go to state 10
    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    discrete_range_mode            shift and go to state 35
    discrete_mode                  shift and go to state 102
    literal_range                  shift and go to state 103
    operand0                       shift and go to state 59
    integer_mode                   shift and go to state 41
    index_mode                     shift and go to state 104
    lower_bound                    shift and go to state 98
    boolean_mode                   shift and go to state 30
    operand1                       shift and go to state 60
    operand2                       shift and go to state 53
    monadic_operator               shift and go to state 56
    index_mode_list                shift and go to state 106
    character_mode                 shift and go to state 37
    identifier                     shift and go to state 105
    discrete_mode_name             shift and go to state 38
    operand3                       shift and go to state 57
    operand4                       shift and go to state 52
    expression                     shift and go to state 97

state 66

    (41) reference_mode -> REF mode .

    ASSIGN          reduce using rule 41 (reference_mode -> REF mode .)
    SEMICOL         reduce using rule 41 (reference_mode -> REF mode .)
    COMMA           reduce using rule 41 (reference_mode -> REF mode .)


state 67

    (34) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (38) literal_range -> . lower_bound COLON upper_bound
    (39) lower_bound -> . expression
    (56) expression -> . operand0
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand2                       shift and go to state 53
    literal_range                  shift and go to state 107
    expression                     shift and go to state 97
    monadic_operator               shift and go to state 56
    operand3                       shift and go to state 57
    operand4                       shift and go to state 52
    lower_bound                    shift and go to state 98
    operand0                       shift and go to state 59
    operand1                       shift and go to state 60

state 68

    (17) synonym_definition -> identifier_list mode ASSIGN . constant_expression
    (19) constant_expression -> . expression
    (56) expression -> . operand0
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand2                       shift and go to state 53
    operand4                       shift and go to state 52
    monadic_operator               shift and go to state 56
    expression                     shift and go to state 55
    operand3                       shift and go to state 57
    constant_expression            shift and go to state 108
    operand0                       shift and go to state 59
    operand1                       shift and go to state 60

state 69

    (15) synonym_list -> synonym_list COMMA synonym_definition .

    SEMICOL         reduce using rule 15 (synonym_list -> synonym_list COMMA synonym_definition .)
    COMMA           reduce using rule 15 (synonym_list -> synonym_list COMMA synonym_definition .)


state 70

    (20) newmode_list -> newmode_list COMMA mode_definition .

    SEMICOL         reduce using rule 20 (newmode_list -> newmode_list COMMA mode_definition .)
    COMMA           reduce using rule 20 (newmode_list -> newmode_list COMMA mode_definition .)


state 71

    (22) mode_definition -> identifier_list ASSIGN mode .

    SEMICOL         reduce using rule 22 (mode_definition -> identifier_list ASSIGN mode .)
    COMMA           reduce using rule 22 (mode_definition -> identifier_list ASSIGN mode .)


state 72

    (10) declaration_list -> declaration_list COMMA declaration .

    SEMICOL         reduce using rule 10 (declaration_list -> declaration_list COMMA declaration .)
    COMMA           reduce using rule 10 (declaration_list -> declaration_list COMMA declaration .)


state 73

    (14) initialization -> ASSIGN . expression
    (56) expression -> . operand0
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand2                       shift and go to state 53
    operand3                       shift and go to state 57
    monadic_operator               shift and go to state 56
    operand0                       shift and go to state 59
    operand1                       shift and go to state 60
    operand4                       shift and go to state 52
    expression                     shift and go to state 109

state 74

    (12) declaration -> identifier_list mode initialization .

    SEMICOL         reduce using rule 12 (declaration -> identifier_list mode initialization .)
    COMMA           reduce using rule 12 (declaration -> identifier_list mode initialization .)


state 75

    (79) arithmetic_multiplicative_operator -> PERC .

    MINUS           reduce using rule 79 (arithmetic_multiplicative_operator -> PERC .)
    NOT             reduce using rule 79 (arithmetic_multiplicative_operator -> PERC .)
    ICONST          reduce using rule 79 (arithmetic_multiplicative_operator -> PERC .)


state 76

    (78) arithmetic_multiplicative_operator -> DIVIDE .

    MINUS           reduce using rule 78 (arithmetic_multiplicative_operator -> DIVIDE .)
    NOT             reduce using rule 78 (arithmetic_multiplicative_operator -> DIVIDE .)
    ICONST          reduce using rule 78 (arithmetic_multiplicative_operator -> DIVIDE .)


state 77

    (76) operand2 -> operand2 arithmetic_multiplicative_operator . operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand3                       shift and go to state 110
    operand4                       shift and go to state 52
    monadic_operator               shift and go to state 56

state 78

    (77) arithmetic_multiplicative_operator -> TIMES .

    MINUS           reduce using rule 77 (arithmetic_multiplicative_operator -> TIMES .)
    NOT             reduce using rule 77 (arithmetic_multiplicative_operator -> TIMES .)
    ICONST          reduce using rule 77 (arithmetic_multiplicative_operator -> TIMES .)


state 79

    (80) operand3 -> monadic_operator operand4 .

    TIMES           reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    DIVIDE          reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    PERC            reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    PLUS            reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    MINUS           reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    AND             reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    OR              reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    EQUALS          reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    DIF             reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    GTR             reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    GEQ             reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    LSS             reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    LEQ             reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    IN              reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    SEMICOL         reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    COMMA           reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    COLON           reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    RPAREN          reduce using rule 80 (operand3 -> monadic_operator operand4 .)
    RBRACK          reduce using rule 80 (operand3 -> monadic_operator operand4 .)


state 80

    (63) relational_operator -> EQUALS .

    MINUS           reduce using rule 63 (relational_operator -> EQUALS .)
    NOT             reduce using rule 63 (relational_operator -> EQUALS .)
    ICONST          reduce using rule 63 (relational_operator -> EQUALS .)


state 81

    (66) relational_operator -> GEQ .

    MINUS           reduce using rule 66 (relational_operator -> GEQ .)
    NOT             reduce using rule 66 (relational_operator -> GEQ .)
    ICONST          reduce using rule 66 (relational_operator -> GEQ .)


state 82

    (69) membership_operator -> IN .

    MINUS           reduce using rule 69 (membership_operator -> IN .)
    NOT             reduce using rule 69 (membership_operator -> IN .)
    ICONST          reduce using rule 69 (membership_operator -> IN .)


state 83

    (58) operand0 -> operand0 operator1 . operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand2                       shift and go to state 53
    operand3                       shift and go to state 57
    monadic_operator               shift and go to state 56
    operand1                       shift and go to state 111
    operand4                       shift and go to state 52

state 84

    (62) relational_operator -> OR .

    MINUS           reduce using rule 62 (relational_operator -> OR .)
    NOT             reduce using rule 62 (relational_operator -> OR .)
    ICONST          reduce using rule 62 (relational_operator -> OR .)


state 85

    (67) relational_operator -> LSS .

    MINUS           reduce using rule 67 (relational_operator -> LSS .)
    NOT             reduce using rule 67 (relational_operator -> LSS .)
    ICONST          reduce using rule 67 (relational_operator -> LSS .)


state 86

    (60) operator1 -> membership_operator .

    MINUS           reduce using rule 60 (operator1 -> membership_operator .)
    NOT             reduce using rule 60 (operator1 -> membership_operator .)
    ICONST          reduce using rule 60 (operator1 -> membership_operator .)


state 87

    (65) relational_operator -> GTR .

    MINUS           reduce using rule 65 (relational_operator -> GTR .)
    NOT             reduce using rule 65 (relational_operator -> GTR .)
    ICONST          reduce using rule 65 (relational_operator -> GTR .)


state 88

    (61) relational_operator -> AND .

    MINUS           reduce using rule 61 (relational_operator -> AND .)
    NOT             reduce using rule 61 (relational_operator -> AND .)
    ICONST          reduce using rule 61 (relational_operator -> AND .)


state 89

    (64) relational_operator -> DIF .

    MINUS           reduce using rule 64 (relational_operator -> DIF .)
    NOT             reduce using rule 64 (relational_operator -> DIF .)
    ICONST          reduce using rule 64 (relational_operator -> DIF .)


state 90

    (59) operator1 -> relational_operator .

    MINUS           reduce using rule 59 (operator1 -> relational_operator .)
    NOT             reduce using rule 59 (operator1 -> relational_operator .)
    ICONST          reduce using rule 59 (operator1 -> relational_operator .)


state 91

    (68) relational_operator -> LEQ .

    MINUS           reduce using rule 68 (relational_operator -> LEQ .)
    NOT             reduce using rule 68 (relational_operator -> LEQ .)
    ICONST          reduce using rule 68 (relational_operator -> LEQ .)


state 92

    (71) operand1 -> operand1 operator2 . operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    operand2                       shift and go to state 112
    operand3                       shift and go to state 57
    monadic_operator               shift and go to state 56
    operand4                       shift and go to state 52

state 93

    (72) operator2 -> arithmetic_additive_operator .

    MINUS           reduce using rule 72 (operator2 -> arithmetic_additive_operator .)
    NOT             reduce using rule 72 (operator2 -> arithmetic_additive_operator .)
    ICONST          reduce using rule 72 (operator2 -> arithmetic_additive_operator .)


state 94

    (74) arithmetic_additive_operator -> MINUS .

    MINUS           reduce using rule 74 (arithmetic_additive_operator -> MINUS .)
    NOT             reduce using rule 74 (arithmetic_additive_operator -> MINUS .)
    ICONST          reduce using rule 74 (arithmetic_additive_operator -> MINUS .)


state 95

    (73) arithmetic_additive_operator -> PLUS .

    MINUS           reduce using rule 73 (arithmetic_additive_operator -> PLUS .)
    NOT             reduce using rule 73 (arithmetic_additive_operator -> PLUS .)
    ICONST          reduce using rule 73 (arithmetic_additive_operator -> PLUS .)


state 96

    (35) discrete_range_mode -> discrete_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 113


state 97

    (39) lower_bound -> expression .

    COLON           reduce using rule 39 (lower_bound -> expression .)


state 98

    (38) literal_range -> lower_bound . COLON upper_bound

    COLON           shift and go to state 114


state 99

    (45) string_length -> integer_literal .

    RBRACK          reduce using rule 45 (string_length -> integer_literal .)


state 100

    (55) integer_literal -> ICONST .

    RBRACK          reduce using rule 55 (integer_literal -> ICONST .)


state 101

    (44) string_mode -> CHARS LBRACK string_length . RBRACK

    RBRACK          shift and go to state 115


state 102

    (49) index_mode -> discrete_mode .
    (35) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    RBRACK          reduce using rule 49 (index_mode -> discrete_mode .)
    COMMA           reduce using rule 49 (index_mode -> discrete_mode .)
    LPAREN          shift and go to state 62


state 103

    (50) index_mode -> literal_range .

    RBRACK          reduce using rule 50 (index_mode -> literal_range .)
    COMMA           reduce using rule 50 (index_mode -> literal_range .)


state 104

    (48) index_mode_list -> index_mode .

    RBRACK          reduce using rule 48 (index_mode_list -> index_mode .)
    COMMA           reduce using rule 48 (index_mode_list -> index_mode .)


state 105

    (37) discrete_mode_name -> identifier .

    LPAREN          reduce using rule 37 (discrete_mode_name -> identifier .)


state 106

    (46) array_mode -> ARRAY LBRACK index_mode_list . RBRACK element_mode
    (47) index_mode_list -> index_mode_list . COMMA index_mode

    RBRACK          shift and go to state 117
    COMMA           shift and go to state 116


state 107

    (34) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 118


state 108

    (17) synonym_definition -> identifier_list mode ASSIGN constant_expression .

    SEMICOL         reduce using rule 17 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)
    COMMA           reduce using rule 17 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)


state 109

    (14) initialization -> ASSIGN expression .

    SEMICOL         reduce using rule 14 (initialization -> ASSIGN expression .)
    COMMA           reduce using rule 14 (initialization -> ASSIGN expression .)


state 110

    (76) operand2 -> operand2 arithmetic_multiplicative_operator operand3 .

    TIMES           reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIVIDE          reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    PERC            reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    PLUS            reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MINUS           reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    AND             reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    OR              reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    EQUALS          reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIF             reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GTR             reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GEQ             reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LSS             reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LEQ             reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    IN              reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COLON           reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    SEMICOL         reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COMMA           reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RPAREN          reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RBRACK          reduce using rule 76 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)


state 111

    (58) operand0 -> operand0 operator1 operand1 .
    (71) operand1 -> operand1 . operator2 operand2
    (72) operator2 -> . arithmetic_additive_operator
    (73) arithmetic_additive_operator -> . PLUS
    (74) arithmetic_additive_operator -> . MINUS

    AND             reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    OR              reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    EQUALS          reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    DIF             reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    GTR             reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    GEQ             reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    LSS             reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    LEQ             reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    IN              reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    COLON           reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    SEMICOL         reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    COMMA           reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    RPAREN          reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    RBRACK          reduce using rule 58 (operand0 -> operand0 operator1 operand1 .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 94

    operator2                      shift and go to state 92
    arithmetic_additive_operator   shift and go to state 93

state 112

    (71) operand1 -> operand1 operator2 operand2 .
    (76) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (77) arithmetic_multiplicative_operator -> . TIMES
    (78) arithmetic_multiplicative_operator -> . DIVIDE
    (79) arithmetic_multiplicative_operator -> . PERC

    PLUS            reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    MINUS           reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    AND             reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    OR              reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    EQUALS          reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    DIF             reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    GTR             reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    GEQ             reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    LSS             reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    LEQ             reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    IN              reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    COLON           reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    SEMICOL         reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    COMMA           reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    RPAREN          reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    RBRACK          reduce using rule 71 (operand1 -> operand1 operator2 operand2 .)
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 76
    PERC            shift and go to state 75

    arithmetic_multiplicative_operator shift and go to state 77

state 113

    (35) discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 35 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 35 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SEMICOL         reduce using rule 35 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 35 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RBRACK          reduce using rule 35 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)


state 114

    (38) literal_range -> lower_bound COLON . upper_bound
    (40) upper_bound -> . expression
    (56) expression -> . operand0
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    monadic_operator               shift and go to state 56
    operand2                       shift and go to state 53
    expression                     shift and go to state 119
    operand0                       shift and go to state 59
    upper_bound                    shift and go to state 120
    operand3                       shift and go to state 57
    operand4                       shift and go to state 52
    operand1                       shift and go to state 60

state 115

    (44) string_mode -> CHARS LBRACK string_length RBRACK .

    ASSIGN          reduce using rule 44 (string_mode -> CHARS LBRACK string_length RBRACK .)
    SEMICOL         reduce using rule 44 (string_mode -> CHARS LBRACK string_length RBRACK .)
    COMMA           reduce using rule 44 (string_mode -> CHARS LBRACK string_length RBRACK .)


state 116

    (47) index_mode_list -> index_mode_list COMMA . index_mode
    (49) index_mode -> . discrete_mode
    (50) index_mode -> . literal_range
    (27) discrete_mode -> . integer_mode
    (28) discrete_mode -> . boolean_mode
    (29) discrete_mode -> . character_mode
    (30) discrete_mode -> . discrete_range_mode
    (38) literal_range -> . lower_bound COLON upper_bound
    (31) integer_mode -> . INT
    (32) boolean_mode -> . BOOL
    (33) character_mode -> . CHAR
    (34) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (35) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (39) lower_bound -> . expression
    (37) discrete_mode_name -> . identifier
    (56) expression -> . operand0
    (54) identifier -> . ID
    (57) operand0 -> . operand1
    (58) operand0 -> . operand0 operator1 operand1
    (70) operand1 -> . operand2
    (71) operand1 -> . operand1 operator2 operand2
    (75) operand2 -> . operand3
    (76) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (80) operand3 -> . monadic_operator operand4
    (81) operand3 -> . operand4
    (82) monadic_operator -> . MINUS
    (83) monadic_operator -> . NOT
    (84) operand4 -> . ICONST

    INT             shift and go to state 36
    BOOL            shift and go to state 23
    CHAR            shift and go to state 26
    ID              shift and go to state 10
    MINUS           shift and go to state 61
    NOT             shift and go to state 51
    ICONST          shift and go to state 54

    discrete_range_mode            shift and go to state 35
    discrete_mode                  shift and go to state 102
    literal_range                  shift and go to state 103
    operand0                       shift and go to state 59
    integer_mode                   shift and go to state 41
    index_mode                     shift and go to state 121
    lower_bound                    shift and go to state 98
    boolean_mode                   shift and go to state 30
    operand1                       shift and go to state 60
    operand2                       shift and go to state 53
    monadic_operator               shift and go to state 56
    character_mode                 shift and go to state 37
    identifier                     shift and go to state 105
    discrete_mode_name             shift and go to state 38
    operand3                       shift and go to state 57
    operand4                       shift and go to state 52
    expression                     shift and go to state 97

state 117

    (46) array_mode -> ARRAY LBRACK index_mode_list RBRACK . element_mode
    (51) element_mode -> . mode
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (26) mode -> . composite_mode
    (36) mode_name -> . identifier
    (27) discrete_mode -> . integer_mode
    (28) discrete_mode -> . boolean_mode
    (29) discrete_mode -> . character_mode
    (30) discrete_mode -> . discrete_range_mode
    (41) reference_mode -> . REF mode
    (42) composite_mode -> . string_mode
    (43) composite_mode -> . array_mode
    (54) identifier -> . ID
    (31) integer_mode -> . INT
    (32) boolean_mode -> . BOOL
    (33) character_mode -> . CHAR
    (34) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (35) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (44) string_mode -> . CHARS LBRACK string_length RBRACK
    (46) array_mode -> . ARRAY LBRACK index_mode_list RBRACK element_mode
    (37) discrete_mode_name -> . identifier

    REF             shift and go to state 34
    ID              shift and go to state 10
    INT             shift and go to state 36
    BOOL            shift and go to state 23
    CHAR            shift and go to state 26
    CHARS           shift and go to state 29
    ARRAY           shift and go to state 32

    string_mode                    shift and go to state 33
    discrete_mode                  shift and go to state 24
    discrete_range_mode            shift and go to state 35
    array_mode                     shift and go to state 25
    character_mode                 shift and go to state 37
    discrete_mode_name             shift and go to state 38
    composite_mode                 shift and go to state 28
    mode                           shift and go to state 122
    integer_mode                   shift and go to state 41
    reference_mode                 shift and go to state 40
    boolean_mode                   shift and go to state 30
    mode_name                      shift and go to state 42
    identifier                     shift and go to state 31
    element_mode                   shift and go to state 123

state 118

    (34) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 34 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 34 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SEMICOL         reduce using rule 34 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 34 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RBRACK          reduce using rule 34 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)


state 119

    (40) upper_bound -> expression .

    RPAREN          reduce using rule 40 (upper_bound -> expression .)
    RBRACK          reduce using rule 40 (upper_bound -> expression .)
    COMMA           reduce using rule 40 (upper_bound -> expression .)


state 120

    (38) literal_range -> lower_bound COLON upper_bound .

    RPAREN          reduce using rule 38 (literal_range -> lower_bound COLON upper_bound .)
    RBRACK          reduce using rule 38 (literal_range -> lower_bound COLON upper_bound .)
    COMMA           reduce using rule 38 (literal_range -> lower_bound COLON upper_bound .)


state 121

    (47) index_mode_list -> index_mode_list COMMA index_mode .

    RBRACK          reduce using rule 47 (index_mode_list -> index_mode_list COMMA index_mode .)
    COMMA           reduce using rule 47 (index_mode_list -> index_mode_list COMMA index_mode .)


state 122

    (51) element_mode -> mode .

    ASSIGN          reduce using rule 51 (element_mode -> mode .)
    SEMICOL         reduce using rule 51 (element_mode -> mode .)
    COMMA           reduce using rule 51 (element_mode -> mode .)


state 123

    (46) array_mode -> ARRAY LBRACK index_mode_list RBRACK element_mode .

    SEMICOL         reduce using rule 46 (array_mode -> ARRAY LBRACK index_mode_list RBRACK element_mode .)
    COMMA           reduce using rule 46 (array_mode -> ARRAY LBRACK index_mode_list RBRACK element_mode .)
    ASSIGN          reduce using rule 46 (array_mode -> ARRAY LBRACK index_mode_list RBRACK element_mode .)

