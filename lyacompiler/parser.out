Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DOWN
    CONCATASSIGN
    TIMESASSIGN
    PRED
    LBRACK
    ELSE
    DO
    DIVIDEASSIGN
    RETURN
    LOC
    TRUE
    PLUSASSIGN
    SUCC
    CIRCUMF
    THEN
    NUM
    CCONST
    PERCASSIGN
    TO
    ELSIF
    END
    ARRAY
    FALSE
    DBLSLASH
    FI
    MINUSASSIGN
    RCURL
    LCURL
    RBRACK
    RESULT
    READ
    FOR
    LOWER
    EXIT
    NULL
    IF
    RETURNS
    DBLQUO
    PROC
    WHILE
    SINGQUO
    CONCAT
    BY
    UPPER
    OD
    CHARS
    ARROW
    PRINT
    SCONST
    LENGTH

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> statement
Rule 4     statement -> declaration_statement
Rule 5     statement -> synonym_statement
Rule 6     statement -> newmode_statement
Rule 7     declaration_statement -> DCL declaration_list SEMICOL
Rule 8     synonym_statement -> SYN synonym_list SEMICOL
Rule 9     newmode_statement -> TYPE newmode_list SEMICOL
Rule 10    declaration_list -> declaration_list COMMA declaration
Rule 11    declaration_list -> declaration
Rule 12    declaration -> identifier_list mode initialization
Rule 13    declaration -> identifier_list mode
Rule 14    initialization -> ASSIGN expression
Rule 15    synonym_list -> synonym_list COMMA synonym_definition
Rule 16    synonym_list -> synonym_definition
Rule 17    synonym_definition -> identifier_list mode ASSIGN constant_expression
Rule 18    synonym_definition -> identifier_list ASSIGN constant_expression
Rule 19    constant_expression -> expression
Rule 20    newmode_list -> newmode_list COMMA mode_definition
Rule 21    newmode_list -> mode_definition
Rule 22    mode_definition -> identifier_list ASSIGN mode
Rule 23    mode -> mode_name
Rule 24    mode -> discrete_mode
Rule 25    mode -> reference_mode
Rule 26    discrete_mode -> integer_mode
Rule 27    discrete_mode -> boolean_mode
Rule 28    discrete_mode -> character_mode
Rule 29    discrete_mode -> discrete_range_mode
Rule 30    integer_mode -> INT
Rule 31    boolean_mode -> BOOL
Rule 32    character_mode -> CHAR
Rule 33    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 34    discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN
Rule 35    mode_name -> identifier
Rule 36    discrete_mode_name -> identifier
Rule 37    literal_range -> lower_bound COLON upper_bound
Rule 38    lower_bound -> expression
Rule 39    upper_bound -> expression
Rule 40    reference_mode -> REF mode
Rule 41    identifier_list -> identifier
Rule 42    identifier_list -> identifier_list COMMA identifier
Rule 43    identifier -> ID
Rule 44    expression -> operand0
Rule 45    operand0 -> operand1
Rule 46    operand0 -> operand0 operator1 operand1
Rule 47    operator1 -> relational_operator
Rule 48    operator1 -> membership_operator
Rule 49    relational_operator -> AND
Rule 50    relational_operator -> OR
Rule 51    relational_operator -> EQUALS
Rule 52    relational_operator -> DIF
Rule 53    relational_operator -> GTR
Rule 54    relational_operator -> GEQ
Rule 55    relational_operator -> LSS
Rule 56    relational_operator -> LEQ
Rule 57    membership_operator -> IN
Rule 58    operand1 -> operand2
Rule 59    operand1 -> operand1 operator2 operand2
Rule 60    operator2 -> arithmetic_additive_operator
Rule 61    arithmetic_additive_operator -> PLUS
Rule 62    arithmetic_additive_operator -> MINUS
Rule 63    operand2 -> operand3
Rule 64    operand2 -> operand2 arithmetic_multiplicative_operator operand3
Rule 65    arithmetic_multiplicative_operator -> TIMES
Rule 66    arithmetic_multiplicative_operator -> DIVIDE
Rule 67    arithmetic_multiplicative_operator -> PERC
Rule 68    operand3 -> monadic_operator operand4
Rule 69    operand3 -> operand4
Rule 70    monadic_operator -> MINUS
Rule 71    monadic_operator -> NOT
Rule 72    operand4 -> ICONST

Terminals, with rules where they appear

AND                  : 49
ARRAY                : 
ARROW                : 
ASSIGN               : 14 17 18 22
BOOL                 : 31
BY                   : 
CCONST               : 
CHAR                 : 32
CHARS                : 
CIRCUMF              : 
COLON                : 37
COMMA                : 10 15 20 42
CONCAT               : 
CONCATASSIGN         : 
DBLQUO               : 
DBLSLASH             : 
DCL                  : 7
DIF                  : 52
DIVIDE               : 66
DIVIDEASSIGN         : 
DO                   : 
DOWN                 : 
ELSE                 : 
ELSIF                : 
END                  : 
EQUALS               : 51
EXIT                 : 
FALSE                : 
FI                   : 
FOR                  : 
GEQ                  : 54
GTR                  : 53
ICONST               : 72
ID                   : 43
IF                   : 
IN                   : 57
INT                  : 30
LBRACK               : 
LCURL                : 
LENGTH               : 
LEQ                  : 56
LOC                  : 
LOWER                : 
LPAREN               : 33 34
LSS                  : 55
MINUS                : 62 70
MINUSASSIGN          : 
NOT                  : 71
NULL                 : 
NUM                  : 
OD                   : 
OR                   : 50
PERC                 : 67
PERCASSIGN           : 
PLUS                 : 61
PLUSASSIGN           : 
PRED                 : 
PRINT                : 
PROC                 : 
RBRACK               : 
RCURL                : 
READ                 : 
REF                  : 40
RESULT               : 
RETURN               : 
RETURNS              : 
RPAREN               : 33 34
SCONST               : 
SEMICOL              : 7 8 9
SINGQUO              : 
SUCC                 : 
SYN                  : 8
THEN                 : 
TIMES                : 65
TIMESASSIGN          : 
TO                   : 
TRUE                 : 
TYPE                 : 9
UPPER                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_additive_operator : 60
arithmetic_multiplicative_operator : 64
boolean_mode         : 27
character_mode       : 28
constant_expression  : 17 18
declaration          : 10 11
declaration_list     : 7 10
declaration_statement : 4
discrete_mode        : 24 34
discrete_mode_name   : 33
discrete_range_mode  : 29
expression           : 14 19 38 39
identifier           : 35 36 41 42
identifier_list      : 12 13 17 18 22 42
initialization       : 12
integer_mode         : 26
literal_range        : 33 34
lower_bound          : 37
membership_operator  : 48
mode                 : 12 13 17 22 40
mode_definition      : 20 21
mode_name            : 23
monadic_operator     : 68
newmode_list         : 9 20
newmode_statement    : 6
operand0             : 44 46
operand1             : 45 46 59
operand2             : 58 59 64
operand3             : 63 64
operand4             : 68 69
operator1            : 46
operator2            : 59
program              : 0
reference_mode       : 25
relational_operator  : 47
statement            : 2 3
statement_list       : 1 2
synonym_definition   : 15 16
synonym_list         : 8 15
synonym_statement    : 5
upper_bound          : 37

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) declaration_statement -> . DCL declaration_list SEMICOL
    (8) synonym_statement -> . SYN synonym_list SEMICOL
    (9) newmode_statement -> . TYPE newmode_list SEMICOL

    DCL             shift and go to state 1
    SYN             shift and go to state 9
    TYPE            shift and go to state 2

    declaration_statement          shift and go to state 8
    statement                      shift and go to state 5
    newmode_statement              shift and go to state 3
    program                        shift and go to state 4
    statement_list                 shift and go to state 6
    synonym_statement              shift and go to state 7

state 1

    (7) declaration_statement -> DCL . declaration_list SEMICOL
    (10) declaration_list -> . declaration_list COMMA declaration
    (11) declaration_list -> . declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (41) identifier_list -> . identifier
    (42) identifier_list -> . identifier_list COMMA identifier
    (43) identifier -> . ID

    ID              shift and go to state 14

    declaration                    shift and go to state 11
    identifier                     shift and go to state 13
    identifier_list                shift and go to state 10
    declaration_list               shift and go to state 12

state 2

    (9) newmode_statement -> TYPE . newmode_list SEMICOL
    (20) newmode_list -> . newmode_list COMMA mode_definition
    (21) newmode_list -> . mode_definition
    (22) mode_definition -> . identifier_list ASSIGN mode
    (41) identifier_list -> . identifier
    (42) identifier_list -> . identifier_list COMMA identifier
    (43) identifier -> . ID

    ID              shift and go to state 14

    identifier_list                shift and go to state 15
    identifier                     shift and go to state 13
    newmode_list                   shift and go to state 16
    mode_definition                shift and go to state 17

state 3

    (6) statement -> newmode_statement .

    DCL             reduce using rule 6 (statement -> newmode_statement .)
    SYN             reduce using rule 6 (statement -> newmode_statement .)
    TYPE            reduce using rule 6 (statement -> newmode_statement .)
    $end            reduce using rule 6 (statement -> newmode_statement .)


state 4

    (0) S' -> program .



state 5

    (3) statement_list -> statement .

    DCL             reduce using rule 3 (statement_list -> statement .)
    SYN             reduce using rule 3 (statement_list -> statement .)
    TYPE            reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)


state 6

    (1) program -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) statement -> . synonym_statement
    (6) statement -> . newmode_statement
    (7) declaration_statement -> . DCL declaration_list SEMICOL
    (8) synonym_statement -> . SYN synonym_list SEMICOL
    (9) newmode_statement -> . TYPE newmode_list SEMICOL

    $end            reduce using rule 1 (program -> statement_list .)
    DCL             shift and go to state 1
    SYN             shift and go to state 9
    TYPE            shift and go to state 2

    declaration_statement          shift and go to state 8
    newmode_statement              shift and go to state 3
    statement                      shift and go to state 18
    synonym_statement              shift and go to state 7

state 7

    (5) statement -> synonym_statement .

    DCL             reduce using rule 5 (statement -> synonym_statement .)
    SYN             reduce using rule 5 (statement -> synonym_statement .)
    TYPE            reduce using rule 5 (statement -> synonym_statement .)
    $end            reduce using rule 5 (statement -> synonym_statement .)


state 8

    (4) statement -> declaration_statement .

    DCL             reduce using rule 4 (statement -> declaration_statement .)
    SYN             reduce using rule 4 (statement -> declaration_statement .)
    TYPE            reduce using rule 4 (statement -> declaration_statement .)
    $end            reduce using rule 4 (statement -> declaration_statement .)


state 9

    (8) synonym_statement -> SYN . synonym_list SEMICOL
    (15) synonym_list -> . synonym_list COMMA synonym_definition
    (16) synonym_list -> . synonym_definition
    (17) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (18) synonym_definition -> . identifier_list ASSIGN constant_expression
    (41) identifier_list -> . identifier
    (42) identifier_list -> . identifier_list COMMA identifier
    (43) identifier -> . ID

    ID              shift and go to state 14

    identifier                     shift and go to state 13
    identifier_list                shift and go to state 19
    synonym_list                   shift and go to state 20
    synonym_definition             shift and go to state 21

state 10

    (12) declaration -> identifier_list . mode initialization
    (13) declaration -> identifier_list . mode
    (42) identifier_list -> identifier_list . COMMA identifier
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (35) mode_name -> . identifier
    (26) discrete_mode -> . integer_mode
    (27) discrete_mode -> . boolean_mode
    (28) discrete_mode -> . character_mode
    (29) discrete_mode -> . discrete_range_mode
    (40) reference_mode -> . REF mode
    (43) identifier -> . ID
    (30) integer_mode -> . INT
    (31) boolean_mode -> . BOOL
    (32) character_mode -> . CHAR
    (33) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (34) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (36) discrete_mode_name -> . identifier

    COMMA           shift and go to state 29
    REF             shift and go to state 22
    ID              shift and go to state 14
    INT             shift and go to state 28
    BOOL            shift and go to state 26
    CHAR            shift and go to state 25

    mode_name                      shift and go to state 24
    reference_mode                 shift and go to state 27
    discrete_mode_name             shift and go to state 34
    mode                           shift and go to state 23
    identifier                     shift and go to state 30
    discrete_mode                  shift and go to state 31
    character_mode                 shift and go to state 32
    integer_mode                   shift and go to state 33
    discrete_range_mode            shift and go to state 35
    boolean_mode                   shift and go to state 36

state 11

    (11) declaration_list -> declaration .

    SEMICOL         reduce using rule 11 (declaration_list -> declaration .)
    COMMA           reduce using rule 11 (declaration_list -> declaration .)


state 12

    (7) declaration_statement -> DCL declaration_list . SEMICOL
    (10) declaration_list -> declaration_list . COMMA declaration

    SEMICOL         shift and go to state 37
    COMMA           shift and go to state 38


state 13

    (41) identifier_list -> identifier .

    COMMA           reduce using rule 41 (identifier_list -> identifier .)
    REF             reduce using rule 41 (identifier_list -> identifier .)
    ID              reduce using rule 41 (identifier_list -> identifier .)
    INT             reduce using rule 41 (identifier_list -> identifier .)
    BOOL            reduce using rule 41 (identifier_list -> identifier .)
    CHAR            reduce using rule 41 (identifier_list -> identifier .)
    ASSIGN          reduce using rule 41 (identifier_list -> identifier .)


state 14

    (43) identifier -> ID .

    ASSIGN          reduce using rule 43 (identifier -> ID .)
    COMMA           reduce using rule 43 (identifier -> ID .)
    REF             reduce using rule 43 (identifier -> ID .)
    ID              reduce using rule 43 (identifier -> ID .)
    INT             reduce using rule 43 (identifier -> ID .)
    BOOL            reduce using rule 43 (identifier -> ID .)
    CHAR            reduce using rule 43 (identifier -> ID .)
    SEMICOL         reduce using rule 43 (identifier -> ID .)
    LPAREN          reduce using rule 43 (identifier -> ID .)


state 15

    (22) mode_definition -> identifier_list . ASSIGN mode
    (42) identifier_list -> identifier_list . COMMA identifier

    ASSIGN          shift and go to state 39
    COMMA           shift and go to state 29


state 16

    (9) newmode_statement -> TYPE newmode_list . SEMICOL
    (20) newmode_list -> newmode_list . COMMA mode_definition

    SEMICOL         shift and go to state 40
    COMMA           shift and go to state 41


state 17

    (21) newmode_list -> mode_definition .

    SEMICOL         reduce using rule 21 (newmode_list -> mode_definition .)
    COMMA           reduce using rule 21 (newmode_list -> mode_definition .)


state 18

    (2) statement_list -> statement_list statement .

    DCL             reduce using rule 2 (statement_list -> statement_list statement .)
    SYN             reduce using rule 2 (statement_list -> statement_list statement .)
    TYPE            reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)


state 19

    (17) synonym_definition -> identifier_list . mode ASSIGN constant_expression
    (18) synonym_definition -> identifier_list . ASSIGN constant_expression
    (42) identifier_list -> identifier_list . COMMA identifier
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (35) mode_name -> . identifier
    (26) discrete_mode -> . integer_mode
    (27) discrete_mode -> . boolean_mode
    (28) discrete_mode -> . character_mode
    (29) discrete_mode -> . discrete_range_mode
    (40) reference_mode -> . REF mode
    (43) identifier -> . ID
    (30) integer_mode -> . INT
    (31) boolean_mode -> . BOOL
    (32) character_mode -> . CHAR
    (33) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (34) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (36) discrete_mode_name -> . identifier

    ASSIGN          shift and go to state 43
    COMMA           shift and go to state 29
    REF             shift and go to state 22
    ID              shift and go to state 14
    INT             shift and go to state 28
    BOOL            shift and go to state 26
    CHAR            shift and go to state 25

    mode_name                      shift and go to state 24
    reference_mode                 shift and go to state 27
    discrete_mode_name             shift and go to state 34
    mode                           shift and go to state 42
    identifier                     shift and go to state 30
    discrete_mode                  shift and go to state 31
    character_mode                 shift and go to state 32
    integer_mode                   shift and go to state 33
    discrete_range_mode            shift and go to state 35
    boolean_mode                   shift and go to state 36

state 20

    (8) synonym_statement -> SYN synonym_list . SEMICOL
    (15) synonym_list -> synonym_list . COMMA synonym_definition

    SEMICOL         shift and go to state 44
    COMMA           shift and go to state 45


state 21

    (16) synonym_list -> synonym_definition .

    SEMICOL         reduce using rule 16 (synonym_list -> synonym_definition .)
    COMMA           reduce using rule 16 (synonym_list -> synonym_definition .)


state 22

    (40) reference_mode -> REF . mode
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (35) mode_name -> . identifier
    (26) discrete_mode -> . integer_mode
    (27) discrete_mode -> . boolean_mode
    (28) discrete_mode -> . character_mode
    (29) discrete_mode -> . discrete_range_mode
    (40) reference_mode -> . REF mode
    (43) identifier -> . ID
    (30) integer_mode -> . INT
    (31) boolean_mode -> . BOOL
    (32) character_mode -> . CHAR
    (33) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (34) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (36) discrete_mode_name -> . identifier

    REF             shift and go to state 22
    ID              shift and go to state 14
    INT             shift and go to state 28
    BOOL            shift and go to state 26
    CHAR            shift and go to state 25

    integer_mode                   shift and go to state 33
    identifier                     shift and go to state 30
    discrete_mode                  shift and go to state 31
    mode_name                      shift and go to state 24
    mode                           shift and go to state 46
    discrete_mode_name             shift and go to state 34
    character_mode                 shift and go to state 32
    reference_mode                 shift and go to state 27
    discrete_range_mode            shift and go to state 35
    boolean_mode                   shift and go to state 36

state 23

    (12) declaration -> identifier_list mode . initialization
    (13) declaration -> identifier_list mode .
    (14) initialization -> . ASSIGN expression

    SEMICOL         reduce using rule 13 (declaration -> identifier_list mode .)
    COMMA           reduce using rule 13 (declaration -> identifier_list mode .)
    ASSIGN          shift and go to state 47

    initialization                 shift and go to state 48

state 24

    (23) mode -> mode_name .

    SEMICOL         reduce using rule 23 (mode -> mode_name .)
    COMMA           reduce using rule 23 (mode -> mode_name .)
    ASSIGN          reduce using rule 23 (mode -> mode_name .)


state 25

    (32) character_mode -> CHAR .

    LPAREN          reduce using rule 32 (character_mode -> CHAR .)
    ASSIGN          reduce using rule 32 (character_mode -> CHAR .)
    SEMICOL         reduce using rule 32 (character_mode -> CHAR .)
    COMMA           reduce using rule 32 (character_mode -> CHAR .)


state 26

    (31) boolean_mode -> BOOL .

    LPAREN          reduce using rule 31 (boolean_mode -> BOOL .)
    ASSIGN          reduce using rule 31 (boolean_mode -> BOOL .)
    SEMICOL         reduce using rule 31 (boolean_mode -> BOOL .)
    COMMA           reduce using rule 31 (boolean_mode -> BOOL .)


state 27

    (25) mode -> reference_mode .

    SEMICOL         reduce using rule 25 (mode -> reference_mode .)
    COMMA           reduce using rule 25 (mode -> reference_mode .)
    ASSIGN          reduce using rule 25 (mode -> reference_mode .)


state 28

    (30) integer_mode -> INT .

    LPAREN          reduce using rule 30 (integer_mode -> INT .)
    ASSIGN          reduce using rule 30 (integer_mode -> INT .)
    SEMICOL         reduce using rule 30 (integer_mode -> INT .)
    COMMA           reduce using rule 30 (integer_mode -> INT .)


state 29

    (42) identifier_list -> identifier_list COMMA . identifier
    (43) identifier -> . ID

    ID              shift and go to state 14

    identifier                     shift and go to state 49

state 30

    (35) mode_name -> identifier .
    (36) discrete_mode_name -> identifier .

    ASSIGN          reduce using rule 35 (mode_name -> identifier .)
    SEMICOL         reduce using rule 35 (mode_name -> identifier .)
    COMMA           reduce using rule 35 (mode_name -> identifier .)
    LPAREN          reduce using rule 36 (discrete_mode_name -> identifier .)


state 31

    (24) mode -> discrete_mode .
    (34) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    SEMICOL         reduce using rule 24 (mode -> discrete_mode .)
    COMMA           reduce using rule 24 (mode -> discrete_mode .)
    ASSIGN          reduce using rule 24 (mode -> discrete_mode .)
    LPAREN          shift and go to state 50


state 32

    (28) discrete_mode -> character_mode .

    LPAREN          reduce using rule 28 (discrete_mode -> character_mode .)
    ASSIGN          reduce using rule 28 (discrete_mode -> character_mode .)
    SEMICOL         reduce using rule 28 (discrete_mode -> character_mode .)
    COMMA           reduce using rule 28 (discrete_mode -> character_mode .)


state 33

    (26) discrete_mode -> integer_mode .

    LPAREN          reduce using rule 26 (discrete_mode -> integer_mode .)
    ASSIGN          reduce using rule 26 (discrete_mode -> integer_mode .)
    SEMICOL         reduce using rule 26 (discrete_mode -> integer_mode .)
    COMMA           reduce using rule 26 (discrete_mode -> integer_mode .)


state 34

    (33) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 51


state 35

    (29) discrete_mode -> discrete_range_mode .

    LPAREN          reduce using rule 29 (discrete_mode -> discrete_range_mode .)
    ASSIGN          reduce using rule 29 (discrete_mode -> discrete_range_mode .)
    SEMICOL         reduce using rule 29 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 29 (discrete_mode -> discrete_range_mode .)


state 36

    (27) discrete_mode -> boolean_mode .

    LPAREN          reduce using rule 27 (discrete_mode -> boolean_mode .)
    ASSIGN          reduce using rule 27 (discrete_mode -> boolean_mode .)
    SEMICOL         reduce using rule 27 (discrete_mode -> boolean_mode .)
    COMMA           reduce using rule 27 (discrete_mode -> boolean_mode .)


state 37

    (7) declaration_statement -> DCL declaration_list SEMICOL .

    DCL             reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)
    SYN             reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)
    TYPE            reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)
    $end            reduce using rule 7 (declaration_statement -> DCL declaration_list SEMICOL .)


state 38

    (10) declaration_list -> declaration_list COMMA . declaration
    (12) declaration -> . identifier_list mode initialization
    (13) declaration -> . identifier_list mode
    (41) identifier_list -> . identifier
    (42) identifier_list -> . identifier_list COMMA identifier
    (43) identifier -> . ID

    ID              shift and go to state 14

    declaration                    shift and go to state 52
    identifier                     shift and go to state 13
    identifier_list                shift and go to state 10

state 39

    (22) mode_definition -> identifier_list ASSIGN . mode
    (23) mode -> . mode_name
    (24) mode -> . discrete_mode
    (25) mode -> . reference_mode
    (35) mode_name -> . identifier
    (26) discrete_mode -> . integer_mode
    (27) discrete_mode -> . boolean_mode
    (28) discrete_mode -> . character_mode
    (29) discrete_mode -> . discrete_range_mode
    (40) reference_mode -> . REF mode
    (43) identifier -> . ID
    (30) integer_mode -> . INT
    (31) boolean_mode -> . BOOL
    (32) character_mode -> . CHAR
    (33) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (34) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (36) discrete_mode_name -> . identifier

    REF             shift and go to state 22
    ID              shift and go to state 14
    INT             shift and go to state 28
    BOOL            shift and go to state 26
    CHAR            shift and go to state 25

    mode_name                      shift and go to state 24
    reference_mode                 shift and go to state 27
    discrete_mode_name             shift and go to state 34
    mode                           shift and go to state 53
    identifier                     shift and go to state 30
    discrete_mode                  shift and go to state 31
    character_mode                 shift and go to state 32
    integer_mode                   shift and go to state 33
    discrete_range_mode            shift and go to state 35
    boolean_mode                   shift and go to state 36

state 40

    (9) newmode_statement -> TYPE newmode_list SEMICOL .

    DCL             reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)
    SYN             reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)
    TYPE            reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)
    $end            reduce using rule 9 (newmode_statement -> TYPE newmode_list SEMICOL .)


state 41

    (20) newmode_list -> newmode_list COMMA . mode_definition
    (22) mode_definition -> . identifier_list ASSIGN mode
    (41) identifier_list -> . identifier
    (42) identifier_list -> . identifier_list COMMA identifier
    (43) identifier -> . ID

    ID              shift and go to state 14

    identifier_list                shift and go to state 15
    identifier                     shift and go to state 13
    mode_definition                shift and go to state 54

state 42

    (17) synonym_definition -> identifier_list mode . ASSIGN constant_expression

    ASSIGN          shift and go to state 55


state 43

    (18) synonym_definition -> identifier_list ASSIGN . constant_expression
    (19) constant_expression -> . expression
    (44) expression -> . operand0
    (45) operand0 -> . operand1
    (46) operand0 -> . operand0 operator1 operand1
    (58) operand1 -> . operand2
    (59) operand1 -> . operand1 operator2 operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 56
    constant_expression            shift and go to state 57
    monadic_operator               shift and go to state 59
    operand0                       shift and go to state 60
    operand4                       shift and go to state 62
    operand1                       shift and go to state 64
    expression                     shift and go to state 65
    operand3                       shift and go to state 66

state 44

    (8) synonym_statement -> SYN synonym_list SEMICOL .

    DCL             reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)
    SYN             reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)
    TYPE            reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)
    $end            reduce using rule 8 (synonym_statement -> SYN synonym_list SEMICOL .)


state 45

    (15) synonym_list -> synonym_list COMMA . synonym_definition
    (17) synonym_definition -> . identifier_list mode ASSIGN constant_expression
    (18) synonym_definition -> . identifier_list ASSIGN constant_expression
    (41) identifier_list -> . identifier
    (42) identifier_list -> . identifier_list COMMA identifier
    (43) identifier -> . ID

    ID              shift and go to state 14

    identifier                     shift and go to state 13
    identifier_list                shift and go to state 19
    synonym_definition             shift and go to state 67

state 46

    (40) reference_mode -> REF mode .

    ASSIGN          reduce using rule 40 (reference_mode -> REF mode .)
    SEMICOL         reduce using rule 40 (reference_mode -> REF mode .)
    COMMA           reduce using rule 40 (reference_mode -> REF mode .)


state 47

    (14) initialization -> ASSIGN . expression
    (44) expression -> . operand0
    (45) operand0 -> . operand1
    (46) operand0 -> . operand0 operator1 operand1
    (58) operand1 -> . operand2
    (59) operand1 -> . operand1 operator2 operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 56
    monadic_operator               shift and go to state 59
    operand0                       shift and go to state 60
    operand4                       shift and go to state 62
    operand1                       shift and go to state 64
    expression                     shift and go to state 68
    operand3                       shift and go to state 66

state 48

    (12) declaration -> identifier_list mode initialization .

    SEMICOL         reduce using rule 12 (declaration -> identifier_list mode initialization .)
    COMMA           reduce using rule 12 (declaration -> identifier_list mode initialization .)


state 49

    (42) identifier_list -> identifier_list COMMA identifier .

    COMMA           reduce using rule 42 (identifier_list -> identifier_list COMMA identifier .)
    REF             reduce using rule 42 (identifier_list -> identifier_list COMMA identifier .)
    ID              reduce using rule 42 (identifier_list -> identifier_list COMMA identifier .)
    INT             reduce using rule 42 (identifier_list -> identifier_list COMMA identifier .)
    BOOL            reduce using rule 42 (identifier_list -> identifier_list COMMA identifier .)
    CHAR            reduce using rule 42 (identifier_list -> identifier_list COMMA identifier .)
    ASSIGN          reduce using rule 42 (identifier_list -> identifier_list COMMA identifier .)


state 50

    (34) discrete_range_mode -> discrete_mode LPAREN . literal_range RPAREN
    (37) literal_range -> . lower_bound COLON upper_bound
    (38) lower_bound -> . expression
    (44) expression -> . operand0
    (45) operand0 -> . operand1
    (46) operand0 -> . operand0 operator1 operand1
    (58) operand1 -> . operand2
    (59) operand1 -> . operand1 operator2 operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 56
    literal_range                  shift and go to state 71
    lower_bound                    shift and go to state 69
    monadic_operator               shift and go to state 59
    operand0                       shift and go to state 60
    operand4                       shift and go to state 62
    operand1                       shift and go to state 64
    expression                     shift and go to state 70
    operand3                       shift and go to state 66

state 51

    (33) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (37) literal_range -> . lower_bound COLON upper_bound
    (38) lower_bound -> . expression
    (44) expression -> . operand0
    (45) operand0 -> . operand1
    (46) operand0 -> . operand0 operator1 operand1
    (58) operand1 -> . operand2
    (59) operand1 -> . operand1 operator2 operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 56
    literal_range                  shift and go to state 72
    lower_bound                    shift and go to state 69
    monadic_operator               shift and go to state 59
    operand0                       shift and go to state 60
    operand4                       shift and go to state 62
    operand1                       shift and go to state 64
    expression                     shift and go to state 70
    operand3                       shift and go to state 66

state 52

    (10) declaration_list -> declaration_list COMMA declaration .

    SEMICOL         reduce using rule 10 (declaration_list -> declaration_list COMMA declaration .)
    COMMA           reduce using rule 10 (declaration_list -> declaration_list COMMA declaration .)


state 53

    (22) mode_definition -> identifier_list ASSIGN mode .

    SEMICOL         reduce using rule 22 (mode_definition -> identifier_list ASSIGN mode .)
    COMMA           reduce using rule 22 (mode_definition -> identifier_list ASSIGN mode .)


state 54

    (20) newmode_list -> newmode_list COMMA mode_definition .

    SEMICOL         reduce using rule 20 (newmode_list -> newmode_list COMMA mode_definition .)
    COMMA           reduce using rule 20 (newmode_list -> newmode_list COMMA mode_definition .)


state 55

    (17) synonym_definition -> identifier_list mode ASSIGN . constant_expression
    (19) constant_expression -> . expression
    (44) expression -> . operand0
    (45) operand0 -> . operand1
    (46) operand0 -> . operand0 operator1 operand1
    (58) operand1 -> . operand2
    (59) operand1 -> . operand1 operator2 operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 56
    monadic_operator               shift and go to state 59
    constant_expression            shift and go to state 73
    operand0                       shift and go to state 60
    operand4                       shift and go to state 62
    operand1                       shift and go to state 64
    expression                     shift and go to state 65
    operand3                       shift and go to state 66

state 56

    (58) operand1 -> operand2 .
    (64) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (65) arithmetic_multiplicative_operator -> . TIMES
    (66) arithmetic_multiplicative_operator -> . DIVIDE
    (67) arithmetic_multiplicative_operator -> . PERC

    PLUS            reduce using rule 58 (operand1 -> operand2 .)
    MINUS           reduce using rule 58 (operand1 -> operand2 .)
    AND             reduce using rule 58 (operand1 -> operand2 .)
    OR              reduce using rule 58 (operand1 -> operand2 .)
    EQUALS          reduce using rule 58 (operand1 -> operand2 .)
    DIF             reduce using rule 58 (operand1 -> operand2 .)
    GTR             reduce using rule 58 (operand1 -> operand2 .)
    GEQ             reduce using rule 58 (operand1 -> operand2 .)
    LSS             reduce using rule 58 (operand1 -> operand2 .)
    LEQ             reduce using rule 58 (operand1 -> operand2 .)
    IN              reduce using rule 58 (operand1 -> operand2 .)
    SEMICOL         reduce using rule 58 (operand1 -> operand2 .)
    COMMA           reduce using rule 58 (operand1 -> operand2 .)
    RPAREN          reduce using rule 58 (operand1 -> operand2 .)
    COLON           reduce using rule 58 (operand1 -> operand2 .)
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 77
    PERC            shift and go to state 74

    arithmetic_multiplicative_operator shift and go to state 76

state 57

    (18) synonym_definition -> identifier_list ASSIGN constant_expression .

    SEMICOL         reduce using rule 18 (synonym_definition -> identifier_list ASSIGN constant_expression .)
    COMMA           reduce using rule 18 (synonym_definition -> identifier_list ASSIGN constant_expression .)


state 58

    (71) monadic_operator -> NOT .

    ICONST          reduce using rule 71 (monadic_operator -> NOT .)


state 59

    (68) operand3 -> monadic_operator . operand4
    (72) operand4 -> . ICONST

    ICONST          shift and go to state 61

    operand4                       shift and go to state 78

state 60

    (44) expression -> operand0 .
    (46) operand0 -> operand0 . operator1 operand1
    (47) operator1 -> . relational_operator
    (48) operator1 -> . membership_operator
    (49) relational_operator -> . AND
    (50) relational_operator -> . OR
    (51) relational_operator -> . EQUALS
    (52) relational_operator -> . DIF
    (53) relational_operator -> . GTR
    (54) relational_operator -> . GEQ
    (55) relational_operator -> . LSS
    (56) relational_operator -> . LEQ
    (57) membership_operator -> . IN

    RPAREN          reduce using rule 44 (expression -> operand0 .)
    SEMICOL         reduce using rule 44 (expression -> operand0 .)
    COMMA           reduce using rule 44 (expression -> operand0 .)
    COLON           reduce using rule 44 (expression -> operand0 .)
    AND             shift and go to state 89
    OR              shift and go to state 87
    EQUALS          shift and go to state 86
    DIF             shift and go to state 79
    GTR             shift and go to state 80
    GEQ             shift and go to state 90
    LSS             shift and go to state 88
    LEQ             shift and go to state 81
    IN              shift and go to state 82

    membership_operator            shift and go to state 85
    relational_operator            shift and go to state 83
    operator1                      shift and go to state 84

state 61

    (72) operand4 -> ICONST .

    TIMES           reduce using rule 72 (operand4 -> ICONST .)
    DIVIDE          reduce using rule 72 (operand4 -> ICONST .)
    PERC            reduce using rule 72 (operand4 -> ICONST .)
    PLUS            reduce using rule 72 (operand4 -> ICONST .)
    MINUS           reduce using rule 72 (operand4 -> ICONST .)
    AND             reduce using rule 72 (operand4 -> ICONST .)
    OR              reduce using rule 72 (operand4 -> ICONST .)
    EQUALS          reduce using rule 72 (operand4 -> ICONST .)
    DIF             reduce using rule 72 (operand4 -> ICONST .)
    GTR             reduce using rule 72 (operand4 -> ICONST .)
    GEQ             reduce using rule 72 (operand4 -> ICONST .)
    LSS             reduce using rule 72 (operand4 -> ICONST .)
    LEQ             reduce using rule 72 (operand4 -> ICONST .)
    IN              reduce using rule 72 (operand4 -> ICONST .)
    SEMICOL         reduce using rule 72 (operand4 -> ICONST .)
    COMMA           reduce using rule 72 (operand4 -> ICONST .)
    COLON           reduce using rule 72 (operand4 -> ICONST .)
    RPAREN          reduce using rule 72 (operand4 -> ICONST .)


state 62

    (69) operand3 -> operand4 .

    TIMES           reduce using rule 69 (operand3 -> operand4 .)
    DIVIDE          reduce using rule 69 (operand3 -> operand4 .)
    PERC            reduce using rule 69 (operand3 -> operand4 .)
    PLUS            reduce using rule 69 (operand3 -> operand4 .)
    MINUS           reduce using rule 69 (operand3 -> operand4 .)
    AND             reduce using rule 69 (operand3 -> operand4 .)
    OR              reduce using rule 69 (operand3 -> operand4 .)
    EQUALS          reduce using rule 69 (operand3 -> operand4 .)
    DIF             reduce using rule 69 (operand3 -> operand4 .)
    GTR             reduce using rule 69 (operand3 -> operand4 .)
    GEQ             reduce using rule 69 (operand3 -> operand4 .)
    LSS             reduce using rule 69 (operand3 -> operand4 .)
    LEQ             reduce using rule 69 (operand3 -> operand4 .)
    IN              reduce using rule 69 (operand3 -> operand4 .)
    SEMICOL         reduce using rule 69 (operand3 -> operand4 .)
    COMMA           reduce using rule 69 (operand3 -> operand4 .)
    COLON           reduce using rule 69 (operand3 -> operand4 .)
    RPAREN          reduce using rule 69 (operand3 -> operand4 .)


state 63

    (70) monadic_operator -> MINUS .

    ICONST          reduce using rule 70 (monadic_operator -> MINUS .)


state 64

    (45) operand0 -> operand1 .
    (59) operand1 -> operand1 . operator2 operand2
    (60) operator2 -> . arithmetic_additive_operator
    (61) arithmetic_additive_operator -> . PLUS
    (62) arithmetic_additive_operator -> . MINUS

    AND             reduce using rule 45 (operand0 -> operand1 .)
    OR              reduce using rule 45 (operand0 -> operand1 .)
    EQUALS          reduce using rule 45 (operand0 -> operand1 .)
    DIF             reduce using rule 45 (operand0 -> operand1 .)
    GTR             reduce using rule 45 (operand0 -> operand1 .)
    GEQ             reduce using rule 45 (operand0 -> operand1 .)
    LSS             reduce using rule 45 (operand0 -> operand1 .)
    LEQ             reduce using rule 45 (operand0 -> operand1 .)
    IN              reduce using rule 45 (operand0 -> operand1 .)
    SEMICOL         reduce using rule 45 (operand0 -> operand1 .)
    COMMA           reduce using rule 45 (operand0 -> operand1 .)
    COLON           reduce using rule 45 (operand0 -> operand1 .)
    RPAREN          reduce using rule 45 (operand0 -> operand1 .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94

    operator2                      shift and go to state 91
    arithmetic_additive_operator   shift and go to state 92

state 65

    (19) constant_expression -> expression .

    SEMICOL         reduce using rule 19 (constant_expression -> expression .)
    COMMA           reduce using rule 19 (constant_expression -> expression .)


state 66

    (63) operand2 -> operand3 .

    TIMES           reduce using rule 63 (operand2 -> operand3 .)
    DIVIDE          reduce using rule 63 (operand2 -> operand3 .)
    PERC            reduce using rule 63 (operand2 -> operand3 .)
    PLUS            reduce using rule 63 (operand2 -> operand3 .)
    MINUS           reduce using rule 63 (operand2 -> operand3 .)
    AND             reduce using rule 63 (operand2 -> operand3 .)
    OR              reduce using rule 63 (operand2 -> operand3 .)
    EQUALS          reduce using rule 63 (operand2 -> operand3 .)
    DIF             reduce using rule 63 (operand2 -> operand3 .)
    GTR             reduce using rule 63 (operand2 -> operand3 .)
    GEQ             reduce using rule 63 (operand2 -> operand3 .)
    LSS             reduce using rule 63 (operand2 -> operand3 .)
    LEQ             reduce using rule 63 (operand2 -> operand3 .)
    IN              reduce using rule 63 (operand2 -> operand3 .)
    COLON           reduce using rule 63 (operand2 -> operand3 .)
    SEMICOL         reduce using rule 63 (operand2 -> operand3 .)
    COMMA           reduce using rule 63 (operand2 -> operand3 .)
    RPAREN          reduce using rule 63 (operand2 -> operand3 .)


state 67

    (15) synonym_list -> synonym_list COMMA synonym_definition .

    SEMICOL         reduce using rule 15 (synonym_list -> synonym_list COMMA synonym_definition .)
    COMMA           reduce using rule 15 (synonym_list -> synonym_list COMMA synonym_definition .)


state 68

    (14) initialization -> ASSIGN expression .

    SEMICOL         reduce using rule 14 (initialization -> ASSIGN expression .)
    COMMA           reduce using rule 14 (initialization -> ASSIGN expression .)


state 69

    (37) literal_range -> lower_bound . COLON upper_bound

    COLON           shift and go to state 95


state 70

    (38) lower_bound -> expression .

    COLON           reduce using rule 38 (lower_bound -> expression .)


state 71

    (34) discrete_range_mode -> discrete_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 96


state 72

    (33) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 97


state 73

    (17) synonym_definition -> identifier_list mode ASSIGN constant_expression .

    SEMICOL         reduce using rule 17 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)
    COMMA           reduce using rule 17 (synonym_definition -> identifier_list mode ASSIGN constant_expression .)


state 74

    (67) arithmetic_multiplicative_operator -> PERC .

    MINUS           reduce using rule 67 (arithmetic_multiplicative_operator -> PERC .)
    NOT             reduce using rule 67 (arithmetic_multiplicative_operator -> PERC .)
    ICONST          reduce using rule 67 (arithmetic_multiplicative_operator -> PERC .)


state 75

    (65) arithmetic_multiplicative_operator -> TIMES .

    MINUS           reduce using rule 65 (arithmetic_multiplicative_operator -> TIMES .)
    NOT             reduce using rule 65 (arithmetic_multiplicative_operator -> TIMES .)
    ICONST          reduce using rule 65 (arithmetic_multiplicative_operator -> TIMES .)


state 76

    (64) operand2 -> operand2 arithmetic_multiplicative_operator . operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    monadic_operator               shift and go to state 59
    operand4                       shift and go to state 62
    operand3                       shift and go to state 98

state 77

    (66) arithmetic_multiplicative_operator -> DIVIDE .

    MINUS           reduce using rule 66 (arithmetic_multiplicative_operator -> DIVIDE .)
    NOT             reduce using rule 66 (arithmetic_multiplicative_operator -> DIVIDE .)
    ICONST          reduce using rule 66 (arithmetic_multiplicative_operator -> DIVIDE .)


state 78

    (68) operand3 -> monadic_operator operand4 .

    TIMES           reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    DIVIDE          reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    PERC            reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    PLUS            reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    MINUS           reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    AND             reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    OR              reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    EQUALS          reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    DIF             reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    GTR             reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    GEQ             reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    LSS             reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    LEQ             reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    IN              reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    SEMICOL         reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    COMMA           reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    COLON           reduce using rule 68 (operand3 -> monadic_operator operand4 .)
    RPAREN          reduce using rule 68 (operand3 -> monadic_operator operand4 .)


state 79

    (52) relational_operator -> DIF .

    MINUS           reduce using rule 52 (relational_operator -> DIF .)
    NOT             reduce using rule 52 (relational_operator -> DIF .)
    ICONST          reduce using rule 52 (relational_operator -> DIF .)


state 80

    (53) relational_operator -> GTR .

    MINUS           reduce using rule 53 (relational_operator -> GTR .)
    NOT             reduce using rule 53 (relational_operator -> GTR .)
    ICONST          reduce using rule 53 (relational_operator -> GTR .)


state 81

    (56) relational_operator -> LEQ .

    MINUS           reduce using rule 56 (relational_operator -> LEQ .)
    NOT             reduce using rule 56 (relational_operator -> LEQ .)
    ICONST          reduce using rule 56 (relational_operator -> LEQ .)


state 82

    (57) membership_operator -> IN .

    MINUS           reduce using rule 57 (membership_operator -> IN .)
    NOT             reduce using rule 57 (membership_operator -> IN .)
    ICONST          reduce using rule 57 (membership_operator -> IN .)


state 83

    (47) operator1 -> relational_operator .

    MINUS           reduce using rule 47 (operator1 -> relational_operator .)
    NOT             reduce using rule 47 (operator1 -> relational_operator .)
    ICONST          reduce using rule 47 (operator1 -> relational_operator .)


state 84

    (46) operand0 -> operand0 operator1 . operand1
    (58) operand1 -> . operand2
    (59) operand1 -> . operand1 operator2 operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 56
    monadic_operator               shift and go to state 59
    operand4                       shift and go to state 62
    operand1                       shift and go to state 99
    operand3                       shift and go to state 66

state 85

    (48) operator1 -> membership_operator .

    MINUS           reduce using rule 48 (operator1 -> membership_operator .)
    NOT             reduce using rule 48 (operator1 -> membership_operator .)
    ICONST          reduce using rule 48 (operator1 -> membership_operator .)


state 86

    (51) relational_operator -> EQUALS .

    MINUS           reduce using rule 51 (relational_operator -> EQUALS .)
    NOT             reduce using rule 51 (relational_operator -> EQUALS .)
    ICONST          reduce using rule 51 (relational_operator -> EQUALS .)


state 87

    (50) relational_operator -> OR .

    MINUS           reduce using rule 50 (relational_operator -> OR .)
    NOT             reduce using rule 50 (relational_operator -> OR .)
    ICONST          reduce using rule 50 (relational_operator -> OR .)


state 88

    (55) relational_operator -> LSS .

    MINUS           reduce using rule 55 (relational_operator -> LSS .)
    NOT             reduce using rule 55 (relational_operator -> LSS .)
    ICONST          reduce using rule 55 (relational_operator -> LSS .)


state 89

    (49) relational_operator -> AND .

    MINUS           reduce using rule 49 (relational_operator -> AND .)
    NOT             reduce using rule 49 (relational_operator -> AND .)
    ICONST          reduce using rule 49 (relational_operator -> AND .)


state 90

    (54) relational_operator -> GEQ .

    MINUS           reduce using rule 54 (relational_operator -> GEQ .)
    NOT             reduce using rule 54 (relational_operator -> GEQ .)
    ICONST          reduce using rule 54 (relational_operator -> GEQ .)


state 91

    (59) operand1 -> operand1 operator2 . operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 100
    monadic_operator               shift and go to state 59
    operand4                       shift and go to state 62
    operand3                       shift and go to state 66

state 92

    (60) operator2 -> arithmetic_additive_operator .

    MINUS           reduce using rule 60 (operator2 -> arithmetic_additive_operator .)
    NOT             reduce using rule 60 (operator2 -> arithmetic_additive_operator .)
    ICONST          reduce using rule 60 (operator2 -> arithmetic_additive_operator .)


state 93

    (61) arithmetic_additive_operator -> PLUS .

    MINUS           reduce using rule 61 (arithmetic_additive_operator -> PLUS .)
    NOT             reduce using rule 61 (arithmetic_additive_operator -> PLUS .)
    ICONST          reduce using rule 61 (arithmetic_additive_operator -> PLUS .)


state 94

    (62) arithmetic_additive_operator -> MINUS .

    MINUS           reduce using rule 62 (arithmetic_additive_operator -> MINUS .)
    NOT             reduce using rule 62 (arithmetic_additive_operator -> MINUS .)
    ICONST          reduce using rule 62 (arithmetic_additive_operator -> MINUS .)


state 95

    (37) literal_range -> lower_bound COLON . upper_bound
    (39) upper_bound -> . expression
    (44) expression -> . operand0
    (45) operand0 -> . operand1
    (46) operand0 -> . operand0 operator1 operand1
    (58) operand1 -> . operand2
    (59) operand1 -> . operand1 operator2 operand2
    (63) operand2 -> . operand3
    (64) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (68) operand3 -> . monadic_operator operand4
    (69) operand3 -> . operand4
    (70) monadic_operator -> . MINUS
    (71) monadic_operator -> . NOT
    (72) operand4 -> . ICONST

    MINUS           shift and go to state 63
    NOT             shift and go to state 58
    ICONST          shift and go to state 61

    operand2                       shift and go to state 56
    upper_bound                    shift and go to state 101
    monadic_operator               shift and go to state 59
    operand0                       shift and go to state 60
    operand4                       shift and go to state 62
    operand1                       shift and go to state 64
    expression                     shift and go to state 102
    operand3                       shift and go to state 66

state 96

    (34) discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 34 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 34 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SEMICOL         reduce using rule 34 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 34 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)


state 97

    (33) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 33 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 33 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SEMICOL         reduce using rule 33 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 33 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)


state 98

    (64) operand2 -> operand2 arithmetic_multiplicative_operator operand3 .

    TIMES           reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIVIDE          reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    PERC            reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    PLUS            reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MINUS           reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    AND             reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    OR              reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    EQUALS          reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIF             reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GTR             reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GEQ             reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LSS             reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LEQ             reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    IN              reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COLON           reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    SEMICOL         reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COMMA           reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RPAREN          reduce using rule 64 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)


state 99

    (46) operand0 -> operand0 operator1 operand1 .
    (59) operand1 -> operand1 . operator2 operand2
    (60) operator2 -> . arithmetic_additive_operator
    (61) arithmetic_additive_operator -> . PLUS
    (62) arithmetic_additive_operator -> . MINUS

    AND             reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    OR              reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    EQUALS          reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    DIF             reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    GTR             reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    GEQ             reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    LSS             reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    LEQ             reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    IN              reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    SEMICOL         reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    COMMA           reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    COLON           reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    RPAREN          reduce using rule 46 (operand0 -> operand0 operator1 operand1 .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94

    operator2                      shift and go to state 91
    arithmetic_additive_operator   shift and go to state 92

state 100

    (59) operand1 -> operand1 operator2 operand2 .
    (64) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (65) arithmetic_multiplicative_operator -> . TIMES
    (66) arithmetic_multiplicative_operator -> . DIVIDE
    (67) arithmetic_multiplicative_operator -> . PERC

    PLUS            reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    MINUS           reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    AND             reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    OR              reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    EQUALS          reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    DIF             reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    GTR             reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    GEQ             reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    LSS             reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    LEQ             reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    IN              reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    SEMICOL         reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    COMMA           reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    RPAREN          reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    COLON           reduce using rule 59 (operand1 -> operand1 operator2 operand2 .)
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 77
    PERC            shift and go to state 74

    arithmetic_multiplicative_operator shift and go to state 76

state 101

    (37) literal_range -> lower_bound COLON upper_bound .

    RPAREN          reduce using rule 37 (literal_range -> lower_bound COLON upper_bound .)


state 102

    (39) upper_bound -> expression .

    RPAREN          reduce using rule 39 (upper_bound -> expression .)

